## 1. Fundamentals of Caching

## 1.1 What is caching and why is it critical in high-throughput banking systems?

## 1.2 Difference between in-memory cache and distributed cache.

## 1.3 What problems does caching solve and what problems does it introduce?

## 1.4 Why is caching considered a performance optimization, not a correctness mechanism?

## 1.5 What is cache hit, miss, and eviction?

## 1.6 Why is caching dangerous for financial data if misused?

## 2. Types of Caching (Where to Cache?)

## 2.1 Client-side caching vs server-side caching – when to use which?

## 2.2 Application-level cache vs database cache – differences and tradeoffs.

## 2.3 Distributed cache (Redis, Hazelcast) vs local cache (Caffeine).

## 2.4 When should you use API Gateway caching in banking?

## 2.5 Browser caching for banking apps – what can and cannot be cached?

## 2.6 Edge/CDN caching – is it safe for banking APIs?

## 3. Cache Patterns

## 3.1 What is Cache-Aside (Lazy Loading) pattern?

## 3.2 Write-through vs write-behind caching – which suits banking transactions?

## 3.3 Read-through cache – how does it differ from cache-aside?

## 3.4 What is refresh-ahead caching and when is it useful?

## 3.5 How does near-cache work in distributed caching?

## 3.6 Which cache pattern is safest for balance-related data?

## 4. Cache Consistency & Data Freshness

## 4.1 How do you ensure cache consistency in banking systems?

## 4.2 What is stale data and why is it dangerous for account balances?

## 4.3 How does TTL help control stale data?

## 4.4 How do you invalidate cache after update operations?

## 4.5 Cache invalidation vs cache update – which is safer?

## 4.6 How do you handle consistency between DB and cache in distributed systems?

## 5. Caching Strategies for Banking Use Cases

## 5.1 What banking data is safe to cache (IFSC, branch info, interest rates)?

## 5.2 Why should account balance never be cached blindly?

## 5.3 How would you cache customer profile data safely?

## 5.4 How do you cache exchange rates with frequent updates?

## 5.5 How would you cache authorization data (roles, permissions)?

## 5.6 Should transaction history be cached? Why or why not?

## 6. Cache Eviction Policies

## 6.1 What are common eviction strategies (LRU, LFU, FIFO)?

## 6.2 Why is LRU commonly used in banking systems?

## 6.3 What happens if eviction policy is poorly chosen?

## 6.4 How do you size cache to avoid frequent evictions?

## 6.5 What is cache thrashing and how do you detect it?

## 7. Distributed Cache Challenges

## 7.1 How does Redis help in distributed banking systems?

## 7.2 How do you handle cache consistency across multiple instances?

## 7.3 What happens if Redis goes down – how should system behave?

## 7.4 How do you prevent cache stampede in high-load systems?

## 7.5 What is cache penetration and how do you avoid it?

## 7.6 How does Redis clustering help with scalability?

## 8. Caching & Transactions

## 8.1 Why should caching not be part of a database transaction?

## 8.2 How do you update cache after successful DB commit?

## 8.3 What happens if DB commit succeeds but cache update fails?

## 8.4 How does eventual consistency apply to cache updates?

## 8.5 Should cache rollback if transaction fails? Why?

## 9. Caching with Microservices

## 9.1 Should each microservice have its own cache or share a cache?

## 9.2 How do you avoid cache duplication across services?

## 9.3 How does caching work with API Gateway + backend services?

## 9.4 How do you propagate cache invalidation events across services?

## 9.5 What are risks of shared cache in microservices?

## 10. Caching & Security

## 10.1 Why should sensitive data (PAN, Aadhaar, CVV) never be cached?

## 10.2 How do you prevent unauthorized access to cached data?

## 10.3 How does encryption help protect cached data?

## 10.4 Should authentication tokens be cached? If yes, where?

## 10.5 How do you prevent cache poisoning attacks?

## 11. Performance & Scalability

## 11.1 How does caching reduce database load in banking apps?

## 11.2 How do you measure cache effectiveness (hit ratio, latency)?

## 11.3 What happens if cache latency becomes higher than DB?

## 11.4 How do you tune cache TTLs for performance vs correctness?

## 11.5 How does caching help during peak hours (salary credit, bill payments)?

## 12. Failure Scenarios & Resilience

## 12.1 What happens when cache is unavailable – fallback strategy?

## 12.2 How do you design cache for graceful degradation?

## 12.3 Cache warming vs cold start – how to handle after restart?

## 12.4 How do you avoid cascading failures caused by cache outage?

## 12.5 Should cache failure block banking transactions? Why or why not?

## 13. Caching with Spring Boot

## 13.1 How does Spring Cache abstraction work internally?

## 13.2 Difference between @Cacheable, @CachePut, and @CacheEvict.

## 13.3 How do you configure Redis as cache provider in Spring Boot?

## 13.4 How do you define different TTLs for different caches?

## 13.5 How do profiles affect caching behavior (dev vs prod)?

## 14. Monitoring, Auditing & Compliance

## 14.1 How do you monitor cache health in production?

## 14.2 What metrics should be tracked for Redis in banking systems?

## 14.3 How do you audit cache usage for compliance?

## 14.4 How do you prove cached data did not affect financial correctness?

## 14.5 How do you log cache misses for investigation?

## 15. Advanced & Real-World Scenarios

## 15.1 User checks balance repeatedly – how do you optimize without caching balance?

## 15.2 High-frequency trading system – is caching acceptable?

## 15.3 How would you cache large account statements efficiently?

## 15.4 How do you handle cache consistency across regions/data centers?

## 15.5 How do you test caching logic in isolation and integration tests?