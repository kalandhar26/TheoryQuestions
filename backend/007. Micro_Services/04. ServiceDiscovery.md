# 1. Service Registration & Deregistration

## How do you register new microservices dynamically in a banking system?

## How does a service automatically register itself with Eureka/Consul on startup?

## How do you handle automatic deregistration when a service shuts down?

## How do you handle service registration for legacy or mainframe banking systems?

## How do you authenticate services before allowing them to register (regulatory requirement)?

## How do you manage service registration for batch jobs and scheduled services?

## How do you handle service registration for notification services and async processors?

# 2. Health Checks, Heartbeats & Instance Lifecycle

## How do you implement health checks for banking services with external dependencies?

## How does service discovery detect and remove unhealthy instances?

## How do you configure heartbeat intervals to detect failures faster?

## How does Eureka mark a service instance as DOWN?

## How do you prevent traffic routing to services that are warming up (cold start)?

## How do you gracefully drain connections during planned maintenance?

## How does circuit-breaker-aware service discovery avoid unhealthy instances?

# 3. High Availability & Fault Tolerance

## What happens if the service registry itself goes down?

## How do you make service discovery highly available for critical banking apps?

## How does Eureka self-preservation help during network glitches?

## How do you handle service discovery failures during peak banking hours?

## How does service discovery behave during network partitions?

## How do you monitor and alert on service registry health?

# 4. Scaling, Load Balancing & Traffic Distribution

## How does service discovery support horizontal scaling of services?

## How does discovery + client-side load balancing distribute traffic across instances?

## How does service discovery help when scaling from 3 to 10 pods during peak load?

## How does discovery ensure smooth load distribution during traffic spikes?

## How do you support services with different SLAs (real-time vs batch)?

## How would you implement weighted routing (90% stable, 10% new)?

## How would you isolate a buggy service instance quickly using discovery?

# 5. Zero-Downtime Deployments & Versioning

## How does service discovery enable zero-downtime deployments?

## How do you handle multiple versions of the same service?

## How do you implement blue-green deployment using service discovery?

## How do you handle rolling upgrades without downtime?

## How do you manage version compatibility between discovery clients and server?

## How do old clients continue using old service versions during upgrades?

# 6. Multi-Region, Multi-Datacenter & Disaster Recovery

## How do you handle service discovery across multiple data centers?

## How does service discovery support disaster recovery setups?

## How does discovery help failover to secondary data centers?

## How do you handle catastrophic failures using service discovery?

## How do you implement geographic routing constraints for compliance?

## How do you handle DNS failures using service discovery?

## How do you implement cost-based routing across availability zones?

# 7. Kubernetes & Cloud-Native Integration

## How does service discovery work in Kubernetes for banking apps?

## How does discovery solve dynamic pod IP changes?

## How does Eureka/Consul integrate with Kubernetes service discovery?

## How do services discover each other across namespaces?

## How do you handle discovery when auto-scaling pods dynamically?

## How do you integrate service discovery with a service mesh?

# 8. Security & Network Segmentation

## How do you secure service discovery communication using TLS?

## How do you secure access to the Eureka/Consul dashboard?

## How do you discover services across security zones (DMZ, internal)?

## How do you manage discovery for internal vs external services?

## How do you enforce authentication and authorization for discovery clients?

# 9. Environment Isolation & Multi-Tenancy

## How do you isolate dev, test, staging, and prod service registries?

## How do you manage service discovery for sandbox vs production?

## How do you handle multi-tenant banking applications?

## How do you configure services to point to the correct registry per environment?

# 10. Integration with API Gateway & Clients

## How do you integrate service discovery with API Gateway?

## How does the gateway use logical service names instead of IPs?

## How does discovery help the gateway route traffic dynamically?

## How do you manage discovery for third-party fintech integrations?

# 11. Monitoring, Observability & Tooling

## How do you monitor service discovery metrics using Prometheus?

## How do you track registration, deregistration, and heartbeat failures?

## How does the Eureka UI help in banking operations?

## How do you alert when services stop registering or flapping?

# 12. Migration, Hybrid Cloud & Legacy Integration

## How do you migrate from monolith to microservices using service discovery?

## How do you handle service discovery in hybrid cloud environments?

## How do you use Consul instead of Eureka in a hybrid banking setup?

## How do you integrate two different service discovery systems during a merger?

# 13. Advanced Metadata & Routing Intelligence

## How do you use metadata tagging (region, version, capability)?

## How does discovery support intelligent routing decisions?

## How do you route based on compliance, latency, or cost constraints?