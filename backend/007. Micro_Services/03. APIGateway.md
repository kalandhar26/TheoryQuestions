# 1. Security, Authentication & Authorization

## How would you secure customer login requests through an API Gateway?

- All login traffic must pass through the API Gateway, never directly to auth services.
- Enforce HTTPS only, block plain HTTP at the gateway itself.
- Apply rate limiting + CAPTCHA challenge on login endpoints to prevent credential stuffing.
- Implement request validation at the gateway to reject malformed payloads, oversized payloads, or unexpected content
  types.
- Customer login requests should be routed through the gateway where rate limiting, IP whitelisting, and bot detection
  are enforced.
- Use mutual TLS (mTLS) if possible for stronger client auth, log all attempts with anomaly detection (e.g., unusual
  geolocation/time/device), and trigger MFA enforcement and CAPTCHA to prevent brute-force attacks or account lockout on
  suspicious patterns. The gateway should never store credentials—only relay to the backend identity provider.
- Deploy rate limiting (per IP/per user) on /login endpoints to prevent credential stuffing and brute-force attacks.
- Use short-lived session tokens (not long-lived credentials) in login responses, issued by the backend authentication
  service after validation.
- Log security events (failed attempts, IPs) for monitoring, but avoid logging sensitive credentials.
- If your gateway allows unlimited login attempts, your auth service becomes a DoS victim.

## How do you enforce SSL/TLS at the API Gateway level?

- Terminate TLS at the gateway using strong certificates (e.g., from internal PKI or trusted CA) and enforce TLS 1.2+
  only.
- Configure the gateway to reject any non-TLS or weak cipher requests (minimum TLS 1.2, preferably TLS 1.3 only),
  disable insecure protocols (SSLv2/3, TLS 1.0/1.1), and use strong modern ciphers (e.g., ECDHE with AES-GCM).
- Configure the API Gateway to only accept HTTPS traffic and redirect all HTTP requests to HTTPS with a strict transport
  security header (HSTS).enable HSTS (HTTP Strict Transport Security) with long max-age to force browser HTTPS, and
  redirect HTTP → HTTPS if any legacy traffic arrives.
- Regularly rotate certificates via automation to prevent expiration outages. Manage certificates (ACM, Azure Key Vault,
  etc.) via a centralized certificate authority.
- Optionally implement mutual TLS (mTLS) for internal microservices or partner APIs. Implement mutual TLS (mTLS) for
  internal microservices communication, ensuring both client and server authenticate each other.

- **uses**
- TLS termination at gateway improves performance.
- End-to-end TLS increases security but adds latency and ops complexity.

## How do you handle authentication tokens (JWT/OAuth) at the API Gateway for internet banking?

## Where and ## How would you implement JWT token validation using Spring Cloud Gateway or Zuul?

## How do you integrate API Gateway with OAuth2 for customer login?

## How would the API Gateway expose APIs securely to third-party fintech partners?

## How do you handle different authentication mechanisms (API keys vs OAuth) for external partners?

## How would you block suspicious IPs at the API Gateway?

## How would you implement IP or country-based blocking for banking APIs?

## How do you separate public APIs (e.g., IFSC lookup) from private banking APIs?

## During a security breach, How would you quickly disable specific API endpoints?

## How would you hide internal service names and ports from external clients?

# 2. Rate Limiting, Throttling & Traffic Control

## How do you handle rate limiting for high-frequency fund transfer APIs?

## How do you implement throttling for ATM withdrawal APIs?

## How can the API Gateway apply per-user rate limiting during promotional or festival traffic?

## How would you protect banking APIs from DDoS while allowing legitimate high-volume traffic?

## During peak banking hours, How would you control traffic hitting the auth service?

## How would you prioritize low-latency services (trading) over non-critical ones (statements)?

## During a cyberattack, How would the API Gateway detect and block abnormal traffic patterns?

# 3. Routing, Load Balancing & Traffic Shaping

## How do you design API Gateway routing to multiple versions of a service?

## How do you implement path-based routing (e.g., /accounts/*, /payments/*)?

## How do you manage routing between microservices in a hybrid cloud?

## How would you route traffic between primary and backup services?

## How do you implement canary routing (e.g., 10% traffic to a new version)?

## How would you implement A/B testing for a new banking feature?

## How would you redirect users to a maintenance page during downtime?

## How would you dynamically register and route a newly added microservice without downtime?

# 4. Resilience, Fault Tolerance & Failover

If a payment service is down, ## How should the API Gateway respond to the mobile app?

## How do you implement circuit breaking at the API Gateway level?

## How do you provide fallback or graceful degradation when a backend service is unavailable?

## How do you manage retries at the API Gateway, and when should you not retry?

During third-party service outages, ## How would you serve cached or partial responses?

# 5. Request / Response Transformation & Aggregation

## How do you manage request and response transformations (e.g., masking account numbers)?

## How would the API Gateway handle different response formats for mobile, web, and ATM clients?

## How would you implement content negotiation at the API Gateway?

## How do you rewrite URLs for backward compatibility (e.g., /v1 → /v2)?

## How do you aggregate responses from multiple services into a single response?

## How would you create an “account summary” by combining account and transaction services?

## How would you implement transformation for legacy banking system integration?

# 6. Caching & Performance Optimization

## How do you cache static or rarely changing data (branch list, IFSC, locator)?

## How can the API Gateway reduce backend load using response caching?

## How would you serve cached balance or branch data during partial outages?

# 7. Versioning & Backward Compatibility

## How do you handle API versioning (v1, v2) in an API Gateway?

## How do you maintain backward compatibility for older mobile apps?

## How do you manage smooth migration when APIs evolve?

## How do you run canary releases during database or service migrations?

# 8. Logging, Monitoring & Audit

## How would you log customer activity at the API Gateway?

## How do you implement centralized audit logging for banking APIs?

## How do you log admin actions separately for compliance?

## How do you monitor latency, error rate, and throughput at the API Gateway?

## How would you integrate gateway logs with SIEM or monitoring tools?

# 9. Fraud Detection & Compliance

## How do you integrate real-time fraud detection checks at the API Gateway?

## How would you inspect requests for fraud signals without impacting latency?

## How would you enforce data sovereignty using geographic routing?

## How do you add mandatory compliance headers to all requests?

## How do you ensure all financial APIs are encrypted and auditable?

# 10. Session Management & Idempotency

## How do you manage customer session state at the API Gateway?

## How would the gateway handle expired tokens during critical flows like fund transfer?

## How would you implement request deduplication for idempotent banking transactions?

# 11. File Uploads & Large Payloads

## How do you handle large payloads such as loan documents or cheque images?

## How would you offload file handling while keeping the gateway lightweight?

# 12. Multi-Region & Global Routing

## How do you route users to the nearest data center in a global banking app?

## How do you handle multi-region failover and disaster recovery?

## How would you implement geo-based routing for regulatory compliance?

# 13. API Exposure & Monetization

## How would you track and monetize API usage for third-party fintech integrations?

## How do you enforce quotas and billing at the API Gateway?

# 14. CORS & Web Security

## How do you handle CORS for web banking portals across multiple domains?