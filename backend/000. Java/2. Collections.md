| Category   | Implementation        | Underlying Structure    | Duplicates | Order     | Thread-Safe | Null Elements | Time Complexity                    | Best For                         | Worst For              |
|------------|-----------------------|-------------------------|------------|-----------|-------------|---------------|------------------------------------|----------------------------------|------------------------|
| **List**   |                       |                         |            |           |             |               |                                    |                                  |                        |
|            | ArrayList             | Dynamic Array           | Yes        | Insertion | No          | Yes           | get/set: O(1)<br>add/remove: O(n)  | Random access                    | Frequent modifications |
|            | LinkedList            | Doubly-Linked List      | Yes        | Insertion | No          | Yes           | get: O(n)<br>add/remove: O(1)      | Frequent modifications           | Random access          |
|            | Vector                | Dynamic Array           | Yes        | Insertion | Yes         | Yes           | get/set: O(1)<br>add/remove: O(n)  | Legacy thread-safe needs         | New projects           |
|            | CopyOnWriteArrayList  | Dynamic Array           | Yes        | Insertion | Yes         | Yes           | get: O(1), add/remove: O(n)        | Frequent reads, rare writes      | Write-heavy scenarios  |
| **Set**    |                       |                         |            |           |             |               |                                    |                                  |                        |
|            | HashSet               | Hash Table              | No         | None      | No          | One null      | O(1)                               | Fast lookups                     | Ordered traversal      |
|            | LinkedHashSet         | Hash Table + LinkedList | No         | Insertion | No          | One null      | O(1)                               | Insertion-order iteration        | Memory usage           |
|            | TreeSet               | Red-Black Tree          | No         | Sorted    | No          | No            | O(log n)                           | Sorted traversal                 | Insertion speed        |
|            | CopyOnWriteArraySet   | Array                   | No         | Insertion | Yes         | Yes           | contains: O(n), add/remove: O(n)   | Read-heavy thread-safe scenarios | Write-heavy scenarios  |
|            | EnumSet               | Bit Vector              | No         | Natural   | No          | No            | All ops: O(1)                      | Enum collections                 | Non-enum elements      |
| **Queue**  |                       |                         |            |           |             |               |                                    |                                  |                        |
|            | PriorityQueue         | Heap                    | Yes        | Sorted    | No          | No            | offer/poll: O(log n)<br>peek: O(1) | Priority processing              | Thread-safety needs    |
|            | ArrayDeque            | Resizable Array         | Yes        | Insertion | No          | No            | O(1)                               | FIFO/LIFO operations             | Thread-safety needs    |
|            | ConcurrentLinkedQueue | Linked Nodes            | Yes        | Insertion | Yes         | No            | offer/poll/peek: O(1)              | Concurrent FIFO                  | Size operations        |
|            | BlockingQueue         | Varies                  | Yes        | Insertion | Yes         | Usually No    | Depends on impl                    | Producer-consumer patterns       | Low-latency needs      |
| **Map**    |                       |                         |            |           |             |               |                                    |                                  |                        |
|            | HashMap               | Hash Table              | No (keys)  | None      | No          | 1 null key    | O(1)                               | General-purpose mapping          | Ordered traversal      |
|            | LinkedHashMap         | Hash Table + LinkedList | No (keys)  | Insertion | No          | 1 null key    | O(1)                               | LRU caches                       | Memory usage           |
|            | TreeMap               | Red-Black Tree          | No (keys)  | Sorted    | No          | No null keys  | O(log n)                           | Range queries                    | Insertion speed        |
|            | ConcurrentHashMap     | Hash Table              | No (keys)  | None      | Yes         | No            | O(1)                               | Concurrent mapping               | Atomic multi-key ops   |
|            | IdentityHashMap       | Hash Table              | No (keys)  | None      | No          | Yes           | get/put/remove: O(1)               | Reference equality mapping       | Normal Map usage       |
|            | WeakHashMap           | Hash Table              | No (keys)  | None      | No          | 1 null key    | get/put/remove: O(1)               | Cache implementations            | Long-term mapping      |
|            | EnumMap               | Array                   | No (keys)  | Natural   | No          | No            | All ops: O(1)                      | Enum keys mapping                | Non-enum keys          |
| **Legacy** |                       |                         |            |           |             |               |                                    |                                  |                        |
|            | Hashtable             | Hash Table              | No (keys)  | None      | Yes         | No            | O(1)                               | Legacy thread-safe needs         | New projects           |
|            | Stack                 | Array                   | Yes        | Insertion | Yes         | Yes           | O(1)                               | LIFO operations                  | General queue use      |

### Key Features Comparison:

1. **Thread Safety**:
    - ✔ Yes: Vector, ConcurrentHashMap, Hashtable
    - ✖ No: Most modern implementations

2. **Null Support**:
    - ✅ Allowed: ArrayList, LinkedList, HashSet
    - ❌ Not Allowed: TreeSet, ConcurrentHashMap

3. **Performance Highlights**:
    - Fastest Access: ArrayList/HashMap (O(1))
    - Best for Sorted Data: TreeSet/TreeMap (O(log n))
    - Best for Concurrent: ConcurrentHashMap

4. **Java 21 Updates**:
    - New sequenced collection interfaces
    - Enhanced immutable collection factories
    - Pattern matching support for collections

### Vector → Modern Alternatives

```java

class MainClass {
    public static void main(Strings[] args) {
// Legacy (discouraged)
        Vector<String> oldVector = new Vector<>();

// Modern Alternatives:
        List<String> arrayList = new ArrayList<>();       // Non-synchronized
        List<String> synchronizedList = Collections.synchronizedList(new ArrayList<>()); // Thread-safe
        List<String> copyOnWriteList = new CopyOnWriteArrayList<>(); // Thread-safe optimized for reads
    }
}
```

### Stack → Modern Alternatives

```java
class MainClass {
    public static void main(Strings[] args) {
// Legacy (discouraged)
        Stack<String> oldStack = new Stack<>();

// Modern Alternatives:
        Deque<String> arrayDeque = new ArrayDeque<>();   // More performant
        Deque<String> linkedList = new LinkedList<>();    // More flexible
        arrayDeque.

                push("item");                          // LIFO operations
        arrayDeque.

                pop();
    }
}
```

### Enumeration → Modern Alternatives

```java

class MainClass {
    public static void main(Strings[] args) {
// Legacy
        Vector<String> v = new Vector<>();
        Enumeration<String> e = v.elements();

// Modern Alternatives:
        Iterator<String> iterator = list.iterator();      // Standard replacement
        Spliterator<String> spliterator = list.spliterator(); // Parallel processing
        list.

                forEach(System.out::println);                // Streams API
    }
}
```

### java.util.Date → Modern Alternatives

```java

class MainClass {
    public static void main(Strings[] args) {
// Legacy (discouraged)
        Date oldDate = new Date();

// Modern Alternatives:
        Instant instant = Instant.now();                  // Time-zone agnostic
        ZonedDateTime zdt = ZonedDateTime.now();         // With timezone
        LocalDate date = LocalDate.now();                // Date only
        LocalTime time = LocalTime.now();                // Time only

// Conversions:
        Date legacyDate = Date.from(instant);            // Interoperability
        Instant fromLegacy = legacyDate.toInstant();
    }
}
```

### Hashtable → Modern Alternatives

```java

class MainClass {
    public static void main(Strings[] args) {
// Legacy (discouraged)
        Hashtable<String, Integer> oldTable = new Hashtable<>();

// Modern Alternatives:
        Map<String, Integer> hashMap = new HashMap<>();            // Non-synchronized
        Map<String, Integer> concurrentMap = new ConcurrentHashMap<>(); // Thread-safe
        Map<String, Integer> synchronizedMap = Collections.synchronizedMap(new HashMap<>());
    }
}
```

### Pattern Matching works with new collections:

```java
class MainClass {
    public static void main(Strings[] args) {
        if (collection instanceof
                ArrayList<String> list) {
            list.forEach(collection);
        }
    }
}
```

### Sequenced Collections (new in Java 21):

```java
class MainClass {
    public static void main(Strings[] args) {
        SequencedCollection<String> seq = new ArrayList<>();
        seq.addFirst("new");  // Unified API across collections
    }
}
```

### Records with new collections:

```java
record Person(String name, LocalDate birth) {
}

List<Person> people = new ArrayList<>();
```

| Legacy Class  | Modern Alternative                             | Key Improvements                                            |
|---------------|------------------------------------------------|-------------------------------------------------------------|
| `Vector`      | `ArrayList` + `Collections.synchronizedList()` | Better performance (≈40% faster), clearer intent            |
| `Stack`       | `ArrayDeque`                                   | 120% faster LIFO operations, memory efficient               |
| `Enumeration` | `Iterator`/`Spliterator`                       | More methods (`remove()`), better stream integration        |
| `Date`        | `java.time` API (`Instant`, `ZonedDateTime`)   | Immutable, thread-safe, nanosecond precision                |
| `Hashtable`   | `ConcurrentHashMap`                            | Higher throughput (up to 8x in Java 21), better concurrency |
| `Dictionary`  | `Map` implementations                          | Proper interface design, rich API                           |

## Internal Working of HashMap?

- A HashMap in Java is a data structure that stores date in key-value pairs.
- It is useful for the fast retrieval and insertion of values based on their keys.
- It internally uses an array of buckets to store these key-value entries.
- In hashmap one key can have only one hash output.
- Two key can also result same output.

### Hashing:

- When you insert a key-value pair into a HashMap, the hash code of the key is computed using the hashCode() method of
  the key object. This hash code is used to determine the index or bucket in the array where the entry will be stored.

### Indexing:

- The computed hash code is then used to find the index within the array of buckets. The index is typically obtained by
  performing a modulo operation on the hash code to ensure it fits within the array size.

### Collisions:

- Collisions occur when two or more keys produce the same hash code and hence map to the same bucket. To handle
  collisions, Java’s HashMap uses a concept called chaining. Each bucket contains a linked list (or a balanced tree in
  later Java 8 versions) of key-value pairs that have the same hash code.

### Insertion:

- When you insert a key-value pair, the HashMap checks if there is already an entry in the bucket corresponding to the
  computed index or not.
- If there is no entry then add a new entry to the bucket. If collision occurs, the newly given
  entry will be added to the existing linked list (or tree) within the bucket.

### Retrieval:

- When you retrieve a value by its key, the HashMap uses the hash code to find the correct bucket. If bucket found then
  it searches through the linked list (or tree) within that bucket to locate the desired key-value pair.

### Resizing:

- To maintain efficiency, the HashMap dynamically resizes its array of buckets when the number of entries crosses a
  certain threshold.
- This helps prevent too many collisions and ensures that the average number of entries per bucket
  remains relatively low.

## Internal Working of Concurrent HashMap?

- A ConcurrentHashMap in Java is a thread-safe data structure that stores data in key-value pairs.
- It is designed for high-concurrency environments, allowing multiple threads to read and write simultaneously with
  minimal blocking.
- It internally uses an array of buckets (like HashMap) to store key-value entries.
- One key always produces one hash output (via hashCode() + spreading).
- Multiple keys can produce the same hash output (collisions).

### Hashing:

- When you insert or access a key-value pair, the hash code of the key is computed using the hashCode() method.
  Java applies an internal spreading function (improved in Java 8+) to reduce collisions and better distribute keys
  across buckets.

### Indexing:

- The final hash value is used to compute the bucket index via a bitwise AND operation (instead of modulo in older
  designs) with (table.length - 1). This maps the key to one of the buckets in the internal array.

### Collisions:

- Collisions occur when two or more keys produce the same hash code and hence map to the same bucket. To handle
  collisions, Java’s HashMap uses a concept called chaining. Each bucket contains a linked list (or a balanced tree in
  later Java 8 versions) of key-value pairs that have the same hash code.

### Insertion and Update:

- ConcurrentHashMap uses a lock-free / low-contention approach in Java 8+ (no more segments!).
- It primarily relies on CAS (Compare-And-Swap) for atomic updates.
- For a put/putIfAbsent/compute/etc.:
- If the bucket is empty → try to place a new node using CAS (no lock).
- If the bucket already has nodes → lock only that bucket's first node (fine-grained locking) using synchronized on the
  head node.
- Then add/ update the entry in the list or tree.
- Multiple threads can update different buckets truly concurrently.
- Reads are almost always lock-free (volatile reads).

### Retrieval:

- When retrieving a value by key, ConcurrentHashMap computes the bucket index.
- It traverses the linked list (or tree) in that bucket without locking (using volatile reads).
- This allows very high read concurrency even during ongoing writes.

### Resizing:

- When the number of entries exceeds a threshold (controlled by load factor), the map resizes (usually doubles the
  bucket array).
- Resizing is done concurrently in Java 8+ — multiple threads can help with the resizing process (using a "transfer"
  mechanism with CAS).
- This avoids blocking the entire map during resize.

## Internal Working of CopyOnWriteArrayList?

- A CopyOnWriteArrayList is a thread-safe variant of ArrayList.
- It is optimized for scenarios where reads are very frequent and writes are rare.
- It internally uses a single volatile array to hold all elements.
- Elements are stored sequentially in an array

### Write Operations (add, set, remove, etc)

- Every mutative operation creates a fresh copy of the entire underlying array.
- The modification (add/remove/set) is applied to this new copy.
- Finally, the internal volatile reference is atomically updated to point to the new array.
- This makes writes expensive (O(n) time & space for copying).

### Read Operations (get, size, contains, iteration):

- Reads directly access the current volatile array — no locking is needed.
- Multiple threads can read concurrently without any synchronization.
- Iterators return a snapshot of the array at the time the iterator was created → they never throw
  ConcurrentModificationException and are immune to concurrent modifications.

### When to use:

- Ideal when iteration / reads >> writes (e.g., event listeners, cache snapshots).
- Very poor performance if frequent writes occur.

## Internal Working of CopyOnWriteArraySet?

- A CopyOnWriteArraySet is a thread-safe Set implementation.
- It does not use hashing internally like HashSet.
- It is backed by a CopyOnWriteArrayList (uses it to store elements).
- Elements are stored in a linear array (via the internal CopyOnWriteArrayList).
  Duplicate prevention is done by checking contains() before adding (linear search → O(n)).

### Write Operations (add, remove):

- Behaves exactly like CopyOnWriteArrayList.
- Every modification creates a new copy of the entire array.
- The change is applied to the copy.
- The internal list reference is updated atomically.

### Read Operations (contains, size, iteration):

- Same as CopyOnWriteArrayList — lock-free reads on the volatile array.
- Iterators provide a consistent snapshot and are safe for concurrent modification of the set.
- Extremely safe & efficient for read-heavy concurrent usage.
- Very expensive for frequent modifications.