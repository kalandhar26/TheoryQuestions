# Streams Code snipper
## Number Operations

```java
List<Integer> numbers = Arrays.asList(1, 2, 8, 9, 10, 11, 14, 15, 17, 19, 4, 5, 6, 7, 8, 9);

// Remove duplicates
List<Integer> distinctNumbers = numbers.stream().distinct().toList();

// Get only duplicates
List<Integer> duplicates = numbers.stream()
    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
    .entrySet().stream()
    .filter(entry -> entry.getValue() > 1)
    .map(Map.Entry::getKey)
    .toList();

// Get only unique numbers
List<Integer> uniqueNumbers = numbers.stream()
    .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
    .entrySet().stream()
    .filter(entry -> entry.getValue() == 1)
    .map(Map.Entry::getKey)
    .toList();

// Sum of squares of even numbers
int evenSquareSum = numbers.stream()
    .filter(num -> num % 2 == 0)
    .mapToInt(n -> n * n)
    .sum();

// Alternative using reduce
int evenSquareSumAlt = numbers.stream()
    .filter(num -> num % 2 == 0)
    .map(n -> n * n)
    .reduce(0, Integer::sum);

// First number greater than 5
int firstGT5 = numbers.stream()
    .sorted()
    .filter(num -> num > 5)
    .findFirst()
    .orElse(0);

// Check if all numbers are positive
boolean allPositive = numbers.stream().allMatch(num -> num > 0);

// Numbers as comma-separated string
String commaSeparated = numbers.stream()
    .map(String::valueOf)
    .collect(Collectors.joining(","));

// Third highest number
int thirdHighest = numbers.stream()
    .sorted()
    .skip(2)
    .findFirst()
    .orElse(0);

// Find Maximum
int maximum = numbers.stream()
                        .reduce(Integer.MIN_VALUE, (a,b)-> a > b ? a : b);

// Concatenate strings
String sentence = words.stream()
                        .reduce("", (a, b) -> a + " " + b);

```

## String Filtering Operations
```java
// Employees whose name starts with R
List<Employee> nameStartsWithR = employees.stream()
    .filter(emp -> emp.getName().toLowerCase().startsWith("r"))
    .toList();

// Employees whose name contains "reddy"
List<Employee> nameContainsReddy = employees.stream()
    .filter(emp -> emp.getName().toLowerCase().contains("reddy"))
    .toList();

// Parallel sum
int sum = numbers.parallelStream()
                 .mapToInt(Integer::intValue)
                 .sum();

// Large List Parallel Processing

List<Integer> bigList = IntStream.rangeClosed(1, 1_000_000)
                                 .boxed()
                                 .toList();
long count = bigList.parallelStream().filter(n -> n % 2 == 0).count();

// Flatten list of lists
List<String> flat = nestedList.stream()
                              .flatMap(Collection::stream)
                              .toList();

// Split sentences into words

List<String> sentences = Arrays.asList("Java is fun", "Streams are powerful");

List<String> words = sentences.stream()
                              .flatMap(sentence -> Arrays.stream(sentence.split(" ")))
                              .toList();

```

## Maximum and Minimum

- maximum salary from employees
```java
Optional<Employee> maxSalariedEmployee = employees.stream().max(Comparator.comparingDouble(Employee::getSalary));
```
- minimum salary from employees
```java
Optional<Employee> maxSalariedEmployee = employees.stream().max(Comparator.comparingDouble(Employee::getSalary));
```
- Maximum Salary of an Employee Department wise
```java
employees.stream().collect)(Collectors.groupingBy(Employee::getName, Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));
```
- Minimum Salary of an Employee Department wise
```java
employees.stream().collect(Collectors.groupingBy(Employee::getName, Collectors.minBy(Comparator.comparingDouble(Employee::getSalary))));
```

- Youngest Employee
```java
employees.stream().min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName).ifPresent(System.out::println);
```
- Oldest Employee
```java
employees.stream().min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName).ifPresent(System.out::println);
```

- Youngest MALE Employee
```java
String youngestMaleEmployee = employees.stream().filter(employee -> employee.getGender.equals("MALE")).min(Comparator.comparingInt(Employee::getAge)).map(Employee::getName);
```
- Youngest Employee based on Gender Wise
```java
employees.stream().collect(Collectors.groupingBy(Employee::getGender, Collectors.minBy(comaprator.ComparingInt(Employee::getAge))));
```


```java
// Nested data flattening (Orders with Products)

List<String> productNames = orders.stream()
                                  .flatMap(order -> order.getProducts().stream())
                                  .map(p -> p.name)
                                  .toList();

                                  String[] wordsArray = {"one", "two", "three", "four", "five"};
// Parallel word count with reduce

String[] wordsArray = {"one", "two", "three", "four", "five"};

int totalLength = Arrays.stream(wordsArray)
                        .parallel()
                        .map(String::length)
                        .reduce(0, Integer::sum);
```


## Basic Filtering and Sorting Operations

```java
// Filter inactive employees
List<Employee> inactiveEmployees = employees.stream()
    .filter(emp -> emp.getStatus().equals("InActive"))
    .toList();

// Sort by salary ascending
List<Employee> sortedBySalaryAsc = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary))
    .toList();

// Sort by salary descending
List<Employee> sortedBySalaryDesc = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .toList();

// Sort by salary (alternative)
List<Employee> sortedBySalaryAlt = employees.stream()
    .sorted((e1, e2) -> (int) (e1.getSalary() - e2.getSalary()))
    .toList();
```

## Grouping Operations

```java
// Group by department
Map<Integer, List<Employee>> employeesByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid));

// Group by department name
Map<String, List<Employee>> employeesByDeptName = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

// Count employees by department
Map<Integer, Long> countByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, Collectors.counting()));

// Count by department name
Map<String, Long> countByDeptName = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.counting()));
```

## Statistical Operations

```java
// Maximum salary
Optional<Employee> maxSalaried = employees.stream()
    .max(Comparator.comparingDouble(Employee::getSalary));

// Minimum salary
Optional<Employee> minSalaried = employees.stream()
    .min(Comparator.comparingDouble(Employee::getSalary));

// Maximum salary department wise
Map<Integer, Optional<Employee>> maxSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, 
             Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));

// Minimum salary department wise
Map<Integer, Optional<Employee>> minSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDeptid, 
             Collectors.minBy(Comparator.comparingDouble(Employee::getSalary))));
```

## Gender-Based Operations

```java
// Count male/female employees
Map<String, Long> genderCount = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, Collectors.counting()));

// Average age by gender
Map<String, Double> avgAgeByGender = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, 
             Collectors.averagingInt(Employee::getAge)));

// Highest paid employee by gender
Map<String, Optional<Employee>> highestPaidByGender = employees.stream()
    .collect(Collectors.groupingBy(Employee::getGender, 
             Collectors.maxBy(Comparator.comparingDouble(Employee::getSalary))));
```

## Age-Based Operations

```java
// Youngest employee
Optional<Employee> youngest = employees.stream()
    .min(Comparator.comparingInt(Employee::getAge));

// Oldest employee
Optional<Employee> oldest = employees.stream()
    .max(Comparator.comparingInt(Employee::getAge));

// Youngest male employee
String youngestMale = employees.stream()
    .filter(e -> e.getGender().equals("MALE"))
    .min(Comparator.comparingInt(Employee::getAge))
    .map(Employee::getName)
    .orElse("Not found");

// Partition minors and majors
Map<Boolean, List<Employee>> partitionedByAge = employees.stream()
    .collect(Collectors.partitioningBy(emp -> emp.getAge() > 18));

// List minor employees
List<String> minorEmployees = employees.stream()
    .filter(e -> e.getAge() < 18)
    .map(Employee::getName)
    .toList();
```

## Salary Operations

```java
// Total salary expenditure
double totalSalary = employees.stream()
    .mapToDouble(Employee::getSalary)
    .sum();

// Average salary
double avgSalary = employees.stream()
    .collect(Collectors.averagingDouble(Employee::getSalary));

// Average salary by department
Map<String, Double> avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment, 
             Collectors.averagingDouble(Employee::getSalary)));

// Second highest paid employee
Optional<Employee> secondHighest = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .skip(1)
    .findFirst();

// Top N highest paid employees
int n = 3;
List<Employee> topN = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .limit(n)
    .toList();

// All employees except top N
List<Employee> exceptTopN = employees.stream()
    .sorted(Comparator.comparingDouble(Employee::getSalary).reversed())
    .skip(n)
    .toList();
```

## Salary Modification Operations

```java
// Increase salary for employees above 20 (display only hiked)
List<Employee> hikedSalaries1 = employees.stream()
    .filter(emp -> emp.getAge() > 20)
    .peek(emp -> emp.setSalary(emp.getSalary() * 1.1))
    .toList();

// Increase salary for employees above 25 (display all)
List<Employee> hikedSalaries2 = employees.stream()
    .peek(emp -> {
        if (emp.getAge() > 25) {
            emp.setSalary(emp.getSalary() * 1.1);
        }
    })
    .toList();
```

## Department and Address Operations

```java
// Print all departments
employees.stream()
    .map(Employee::getDepartment)
    .distinct()
    .forEach(System.out::println);

// Group by city
Map<String, List<Employee>> byCity = employees.stream()
    .collect(Collectors.groupingBy(emp -> emp.getAddress().getCity()));

// Group by state
Map<String, List<Employee>> byState = employees.stream()
    .collect(Collectors.groupingBy(emp -> emp.getAddress().getState()));

// Employees from specific city and state
List<Employee> fromSpecificLocation = employees.stream()
    .filter(emp -> "AP".equalsIgnoreCase(emp.getAddress().getState()) 
                && "Pileru".equalsIgnoreCase(emp.getAddress().getCity()))
    .toList();
```

## Hobby Operations

```java
// Get all unique hobbies
List<String> allHobbies = employees.stream()
    .map(Employee::getHobbies)
    .flatMap(List::stream)
    .distinct()
    .toList();

// Count employees by hobby
Map<String, Long> countByHobby = employees.stream()
    .flatMap(emp -> emp.getHobbies().stream()
        .map(hobby -> new AbstractMap.SimpleEntry<>(hobby, emp)))
    .collect(Collectors.groupingBy(Map.Entry::getKey, Collectors.counting()));

// Employees with at least N common hobbies
int minCommonHobbies = 3;
Map<String, List<Employee>> byCommonHobbies = employees.stream()
    .flatMap(emp -> emp.getHobbies().stream()
        .map(hobby -> new AbstractMap.SimpleEntry<>(hobby.toLowerCase(), emp)))
    .collect(Collectors.groupingBy(Map.Entry::getKey, 
             Collectors.mapping(Map.Entry::getValue, Collectors.toList())));
```

## Complex Department Operations

```java
// Employees working in multiple departments
Map<String, List<Employee>> deptWiseEmployees = employees.stream()
    .flatMap(emp -> emp.getDepartments().stream()
        .map(dept -> new AbstractMap.SimpleEntry<>(dept.getName(), emp)))
    .collect(Collectors.groupingBy(AbstractMap.SimpleEntry::getKey, 
             Collectors.mapping(AbstractMap.SimpleEntry::getValue, Collectors.toList())));

// Employees working in at least 2 departments
List<String> multiDeptEmployees = employees.stream()
    .filter(emp -> emp.getDepartments().size() >= 2)
    .map(Employee::getName)
    .toList();

// Employee names with their departments
Map<String, List<String>> empDeptMapping = employees.stream()
    .collect(Collectors.toMap(Employee::getName, 
             emp -> emp.getDepartments().stream().map(Department::getName).toList()));
```

## Year-Based Operations

```java
// Employees passed out after 2020
List<Employee> recentGraduates = employees.stream()
    .filter(emp -> emp.getPassedOutyear() > 2020)
    .toList();

// Unique passout years in descending order
List<Integer> uniquePassOutYears = employees.stream()
    .map(Employee::getPassedOutyear)
    .distinct()
    .sorted(Comparator.reverseOrder())
    .toList();

// Duplicate passout years
List<Integer> duplicatePassOutYears = employees.stream()
    .map(Employee::getPassedOutyear)
    .filter(year -> employees.stream()
        .filter(emp -> emp.getPassedOutyear() == year).count() > 1)
    .distinct()
    .toList();
```

















