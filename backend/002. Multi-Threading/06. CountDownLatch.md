### CountDownLatch

- A one-time gate that allows threads to wait until a set of operations completes
- A starting line where runners wait until the starter's gun fires (one-time use)

#### CountDownLatch Deep Dive

| Method                        | Description           | Behavior                                          |
|-------------------------------|-----------------------|---------------------------------------------------|
| CountDownLatch(int count)     | Constructor           | Creates latch with initial count                  |
| await()                       | Waits indefinitely    | Blocks until count reaches 0                      |
| await(long timeout, TimeUnit) | Waits with timeout    | Returns false if timeout occurs before reaching 0 |
| countDown()                   | Decrements count      | When count hits 0, releases all waiting threads   |
| getCount()                    | Returns current count | Diagnostic purposes only                          |

##### Basic Usage - Starting a Race

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class RaceExample {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch startSignal = new CountDownLatch(1); // Start gate
        CountDownLatch finishSignal = new CountDownLatch(3); // 3 runners

        System.out.println("=== Race Preparation ===");

        // Create 3 runners
        for (int i = 1; i <= 3; i++) {
            int runnerId = i;
            new Thread(() -> {
                try {
                    System.out.println("Runner " + runnerId + " ready at starting line");

                    // Wait for start signal
                    startSignal.await();

                    System.out.println("Runner " + runnerId + " started running!");

                    // Simulate running
                    Thread.sleep((long) (Math.random() * 3000));

                    System.out.println("Runner " + runnerId + " FINISHED! üèÅ");

                    // Signal finished
                    finishSignal.countDown();

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }

        // Prepare race...
        Thread.sleep(2000);
        System.out.println("\nüèÅ STARTING RACE! üèÅ\n");

        // Fire start signal - releases all runners
        startSignal.countDown(); // count: 1 -> 0

        // Wait for all runners to finish
        finishSignal.await(); // blocks until count becomes 0

        System.out.println("\n‚úÖ All runners finished! Race complete!");
    }
}
```

output

```text
=== Race Preparation ===
Runner 1 ready at starting line
Runner 2 ready at starting line
Runner 3 ready at starting line

üèÅ STARTING RACE! üèÅ

Runner 2 started running!
Runner 1 started running!
Runner 3 started running!
Runner 2 FINISHED! üèÅ
Runner 1 FINISHED! üèÅ
Runner 3 FINISHED! üèÅ

‚úÖ All runners finished! Race complete!
```

##### Service Startup - Wait for Dependencies

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadLocalRandom;

class Service extends Thread {
    private final String serviceName;
    private final CountDownLatch latch;
    private final int startupTime;

    public Service(String serviceName, CountDownLatch latch) {
        this.serviceName = serviceName;
        this.latch = latch;
        this.startupTime = ThreadLocalRandom.current().nextInt(1000, 5000);
    }

    @Override
    public void run() {
        try {
            System.out.println("üîß " + serviceName + " starting up... (will take " +
                    startupTime + "ms)");
            Thread.sleep(startupTime);
            System.out.println("‚úÖ " + serviceName + " is ready!");

            // Signal that this service is ready
            latch.countDown();

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class ApplicationStartup {
    public static void main(String[] args) {
        System.out.println("=== Application Startup ===\n");

        // We need 3 services to start before app is ready
        CountDownLatch servicesLatch = new CountDownLatch(3);

        // Start services
        new Service("Database", servicesLatch).start();
        new Service("Cache", servicesLatch).start();
        new Service("Message Queue", servicesLatch).start();

        try {
            System.out.println("\n‚è≥ Main thread waiting for all services...\n");

            // Wait for all services (with timeout)
            if (servicesLatch.await(10, java.util.concurrent.TimeUnit.SECONDS)) {
                System.out.println("\nüöÄ All services ready! Starting application...");
            } else {
                System.out.println("\n‚ùå Timeout! Services failed to start in time");
                System.out.println("Services remaining: " + servicesLatch.getCount());
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

output

```text
=== Application Startup ===

üîß Database starting up... (will take 2345ms)
üîß Cache starting up... (will take 3891ms)
üîß Message Queue starting up... (will take 1567ms)

‚è≥ Main thread waiting for all services...

‚úÖ Database is ready!
‚úÖ Message Queue is ready!
‚úÖ Cache is ready!

üöÄ All services ready! Starting application...
```

##### Parallel Processing with Timeout

```java
import java.util.concurrent.*;
import java.util.*;

class DataProcessor {
    private final String processorId;

    public DataProcessor(String processorId) {
        this.processorId = processorId;
    }

    public List<String> process(List<String> data) {
        System.out.println("üîÑ Processor " + processorId + " processing " +
                data.size() + " items");

        List<String> results = new ArrayList<>();
        for (String item : data) {
            // Simulate processing
            try {
                Thread.sleep(100);
            } catch (Exception e) {
            }
            results.add(item.toUpperCase() + "-processed-by-" + processorId);
        }

        System.out.println("‚úÖ Processor " + processorId + " completed");
        return results;
    }
}

public class ParallelProcessing {
    public static void main(String[] args) {
        // Create data to process
        List<String> data = Arrays.asList("a", "b", "c", "d", "e", "f", "g", "h");
        int chunkSize = 2;

        // Split data into chunks
        List<List<String>> chunks = new ArrayList<>();
        for (int i = 0; i < data.size(); i += chunkSize) {
            chunks.add(data.subList(i, Math.min(i + chunkSize, data.size())));
        }

        System.out.println("=== Parallel Data Processing ===");
        System.out.println("Total items: " + data.size());
        System.out.println("Chunks: " + chunks.size() + "\n");

        // Create latch for all processors
        CountDownLatch latch = new CountDownLatch(chunks.size());
        List<Future<List<String>>> futures = new ArrayList<>();

        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {

            // Submit each chunk for processing
            for (int i = 0; i < chunks.size(); i++) {
                final int chunkIndex = i;
                final List<String> chunk = chunks.get(i);

                Future<List<String>> future = executor.submit(() -> {
                    try {
                        DataProcessor processor = new DataProcessor("P" + chunkIndex);
                        List<String> result = processor.process(chunk);
                        return result;
                    } finally {
                        latch.countDown(); // Signal completion regardless of success/failure
                    }
                });

                futures.add(future);
            }

            // Wait for all processors with timeout
            try {
                System.out.println("‚è≥ Main waiting for all processors...\n");

                if (latch.await(3, TimeUnit.SECONDS)) {
                    System.out.println("\n‚úÖ All processors completed in time!");

                    // Collect results
                    List<String> allResults = new ArrayList<>();
                    for (Future<List<String>> future : futures) {
                        allResults.addAll(future.get()); // get() won't block - already done
                    }

                    System.out.println("Total results: " + allResults.size());
                    System.out.println("Results: " + allResults);

                } else {
                    System.out.println("\n‚ùå Timeout! Processors taking too long");
                    System.out.println("Remaining: " + latch.getCount());

                    // Cancel remaining futures
                    for (Future<List<String>> future : futures) {
                        if (!future.isDone()) {
                            future.cancel(true);
                        }
                    }
                }

            } catch (InterruptedException e) {
                System.out.println("Main thread interrupted");
            }
        }
    }
}
```

output:

```text
=== Parallel Data Processing ===
Total items: 8
Chunks: 4

‚è≥ Main waiting for all processors...

üîÑ Processor P0 processing 2 items
üîÑ Processor P1 processing 2 items
üîÑ Processor P2 processing 2 items
üîÑ Processor P3 processing 2 items
‚úÖ Processor P0 completed
‚úÖ Processor P1 completed
‚úÖ Processor P2 completed
‚úÖ Processor P3 completed

‚úÖ All processors completed in time!
Total results: 8
Results: [A-processed-by-P0, B-processed-by-P0, C-processed-by-P1, ...]
```

### Common Pitfalls

```java
public class LatchPitfalls {

    // ‚ùå WRONG: Forgetting to countDown() in finally block
    public void badExample() {
        CountDownLatch latch = new CountDownLatch(1);

        new Thread(() -> {
            try {
                // Some work that might throw exception
                throw new RuntimeException("Oops!");
                // latch.countDown(); // NEVER REACHED! Thread hangs forever!
            } catch (Exception e) {
                // Exception caught but no countDown
            }
        }).start();

        try {
            latch.await(); // BLOCKS FOREVER! üíÄ
        } catch (InterruptedException e) {
        }
    }

    // ‚úÖ CORRECT: Always countDown() in finally
    public void goodExample() {
        CountDownLatch latch = new CountDownLatch(1);

        new Thread(() -> {
            try {
                // Some work
                throw new RuntimeException("Oops!");
            } finally {
                latch.countDown(); // ALWAYS executed
            }
        }).start();

        try {
            latch.await(5, TimeUnit.SECONDS); // Use timeout!
        } catch (InterruptedException e) {
        }
    }

    // ‚ùå WRONG: Trying to reuse latch
    public void reuseLatch() {
        CountDownLatch latch = new CountDownLatch(2);

        // First use
        latch.countDown();
        latch.countDown(); // Count reaches 0
        latch.await(); // Works fine

        // Second use - NOT POSSIBLE!
        // latch = new CountDownLatch(2); // Must create new instance
    }
}
```