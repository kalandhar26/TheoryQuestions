### Thread Communication

- wait() / notify() ; Used inside synchronized blocks. Old style, complex, error-prone.
- In Modern way we can use BlockingQueue

### Without Communication

```java
class Kitchen {
    private String food = null;

    // Cook prepares food
    public void cook(String meal) {
        food = meal;
        System.out.println("Cook prepared: " + meal);
    }

    // Waiter serves food
    public String serve() {
        return food;
    }
}

public class WrongWay {
    public static void main(String[] args) {
        Kitchen kitchen = new Kitchen();

        // Cook thread
        Thread cook = new Thread(() -> {
            kitchen.cook("Pizza");
        });

        // Waiter thread
        Thread waiter = new Thread(() -> {
            String meal = kitchen.serve();
            System.out.println("Waiter served: " + meal);
        });

        cook.start();
        waiter.start();
        // PROBLEM: Waiter might run before cook - serves null!
    }
}
```

### Legacy Way - wait() and notify()

```java
class TraditionalKitchen {
    private String food = null;
    private boolean foodReady = false;

    // Cook - PRODUCER
    public synchronized void cook(String meal) {
        // If food is already there, wait until it's served
        while (foodReady) {
            try {
                System.out.println("Cook waiting... kitchen has food");
                wait(); // Releases lock and waits
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // Prepare food
        food = meal;
        foodReady = true;
        System.out.println("üë®‚Äçüç≥ Cook prepared: " + meal);

        // Notify waiting threads (waiters)
        notify(); // Wakes up one waiting thread
        // notifyAll(); // Wakes up all waiting threads
    }

    // Waiter - CONSUMER
    public synchronized String serve() {
        // If no food, wait until cook prepares
        while (!foodReady) {
            try {
                System.out.println("Waiter waiting... no food yet");
                wait(); // Releases lock and waits
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        // Serve food
        foodReady = false;
        System.out.println("üë®‚Äçüíº Waiter served: " + food);

        // Notify cook that food is taken
        notify(); // Wakes up cook

        return food;
    }
}

// Test the traditional way
public class TraditionalCommunication {
    public static void main(String[] args) {
        TraditionalKitchen kitchen = new TraditionalKitchen();

        // Waiter thread (should wait if no food)
        Thread waiter = new Thread(() -> {
            for (int i = 0; i < 3; i++) {
                kitchen.serve();
                try {
                    Thread.sleep(1000);
                } catch (Exception e) {
                }
            }
        }, "Waiter-1");

        // Cook thread
        Thread cook = new Thread(() -> {
            String[] meals = {"Pizza", "Pasta", "Burger"};
            for (String meal : meals) {
                kitchen.cook(meal);
                try {
                    Thread.sleep(500);
                } catch (Exception e) {
                }
            }
        }, "Cook-1");

        cook.start();
        waiter.start();
    }
}
```

- output

```text
Waiter waiting... no food yet
üë®‚Äçüç≥ Cook prepared: Pizza
üë®‚Äçüíº Waiter served: Pizza
Waiter waiting... no food yet
üë®‚Äçüç≥ Cook prepared: Pasta
üë®‚Äçüíº Waiter served: Pasta
Waiter waiting... no food yet
üë®‚Äçüç≥ Cook prepared: Burger
üë®‚Äçüíº Waiter served: Burger
```

#### Why wait/notify is Complex and Error-Prone

```java
// Common mistakes with wait/notify
class ErrorProneExample {
    private Object lock = new Object();
    private boolean condition = false;

    public void badExample() {
        // MISTAKE 1: Forgetting synchronized
        // wait(); // IllegalMonitorStateException!

        synchronized (lock) {
            // MISTAKE 2: Using if instead of while
            if (!condition) {  // Wrong! Should use while
                try {
                    wait(); // Thread might wake up but condition still false
                } catch (InterruptedException e) {
                }
            }

            // MISTAKE 3: Notify before condition is set
            condition = false;
            notify(); // Waiter wakes up to false condition!
        }
    }
}
```

### Modern Way - BlockingQueue (Much Simpler!)

```java
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

class ModernKitchen {
    // BlockingQueue handles all the waiting/notifying automatically!
    private BlockingQueue<String> foodQueue = new ArrayBlockingQueue<>(5); // Max 5 items

    // Cook - PRODUCER
    public void cook(String meal) {
        try {
            System.out.println("üë®‚Äçüç≥ Preparing: " + meal);
            Thread.sleep(1000); // Cooking time

            // put() will wait automatically if queue is full
            foodQueue.put(meal);
            System.out.println("üë®‚Äçüç≥ Finished: " + meal + " (Queue size: " + foodQueue.size() + ")");

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // Waiter - CONSUMER
    public String serve() {
        try {
            System.out.println("üë®‚Äçüíº Waiting to serve...");

            // take() will wait automatically if queue is empty
            String meal = foodQueue.take();
            System.out.println("üë®‚Äçüíº Serving: " + meal + " (Queue size: " + foodQueue.size() + ")");
            return meal;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return null;
        }
    }
}

// Test the modern way
public class ModernCommunication {
    public static void main(String[] args) {
        ModernKitchen kitchen = new ModernKitchen();

        // Multiple waiters (consumers)
        Thread waiter1 = new Thread(() -> {
            for (int i = 0; i < 3; i++) kitchen.serve();
        }, "Waiter-John");

        Thread waiter2 = new Thread(() -> {
            for (int i = 0; i < 2; i++) kitchen.serve();
        }, "Waiter-Jane");

        // Multiple cooks (producers)
        Thread cook1 = new Thread(() -> {
            String[] meals = {"Pizza", "Pasta", "Burger"};
            for (String meal : meals) kitchen.cook(meal);
        }, "Cook-Mike");

        Thread cook2 = new Thread(() -> {
            String[] meals = {"Salad", "Soup"};
            for (String meal : meals) kitchen.cook(meal);
        }, "Cook-Sarah");

        cook1.start();
        cook2.start();
        waiter1.start();
        waiter2.start();
    }
}
```

### Example : Print Shop with Multiple Printers

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

class PrintJob {
    String documentName;
    int pages;

    PrintJob(String documentName, int pages) {
        this.documentName = documentName;
        this.pages = pages;
    }

    @Override
    public String toString() {
        return documentName + "(" + pages + " pages)";
    }
}

class PrintShop {
    private BlockingQueue<PrintJob> printQueue = new LinkedBlockingQueue<>(10);
    private int totalPrinted = 0;

    // Customers submit print jobs (PRODUCERS)
    public void submitPrintJob(String document, int pages) {
        try {
            PrintJob job = new PrintJob(document, pages);
            System.out.println("üìÑ Customer submitted: " + job);

            // offer with timeout - wait max 3 seconds if queue is full
            boolean submitted = printQueue.offer(job, 3, TimeUnit.SECONDS);

            if (!submitted) {
                System.out.println("‚ùå Print shop busy! " + document + " rejected");
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // Printers process jobs (CONSUMERS)
    public void printerWork(String printerName) {
        try {
            while (true) {
                // Take job from queue (waits if none available)
                PrintJob job = printQueue.take();

                System.out.println("üñ®Ô∏è " + printerName + " printing: " + job);
                Thread.sleep(job.pages * 100); // Simulate printing time

                totalPrinted++;
                System.out.println("‚úÖ " + printerName + " completed: " + job +
                        " (Total printed: " + totalPrinted + ")");
            }
        } catch (InterruptedException e) {
            System.out.println(printerName + " shutting down...");
            Thread.currentThread().interrupt();
        }
    }

    // Check current status without blocking
    public void checkStatus() {
        System.out.println("üìä Queue size: " + printQueue.size() +
                ", Jobs waiting: " + printQueue);
    }
}

// Run the print shop
public class PrintShopDemo {
    public static void main(String[] args) throws InterruptedException {
        PrintShop shop = new PrintShop();

        // Start two printers (consumers)
        Thread printer1 = new Thread(() -> shop.printerWork("Printer-HP"), "HP-Printer");
        Thread printer2 = new Thread(() -> shop.printerWork("Printer-Canon"), "Canon-Printer");

        printer1.start();
        printer2.start();

        // Simulate customers submitting jobs (producers)
        Thread[] customers = new Thread[5];
        for (int i = 0; i < customers.length; i++) {
            final int customerId = i;
            customers[i] = new Thread(() -> {
                String[] docs = {"Report.pdf", "Thesis.docx", "Photos.jpg",
                        "Invoice.xls", "Manual.pdf"};
                int[] pages = {5, 20, 3, 1, 15};

                // Each customer submits multiple jobs
                for (int j = 0; j < 3; j++) {
                    int index = (customerId + j) % docs.length;
                    shop.submitPrintJob(docs[index], pages[index]);

                    try {
                        Thread.sleep(500);
                    } catch (Exception e) {
                    }
                }
            }, "Customer-" + i);

            customers[i].start();
        }

        // Check status periodically
        for (int i = 0; i < 5; i++) {
            Thread.sleep(2000);
            shop.checkStatus();
        }
    }
}
```

### Other Modern Communication Tools

#### Exchanger - Two threads exchange data

```java
import java.util.concurrent.Exchanger;

class ExchangerExample {
    public static void main(String[] args) {
        Exchanger<String> exchanger = new Exchanger<>();

        Thread thread1 = new Thread(() -> {
            try {
                String data1 = "Data from Thread 1";
                System.out.println("Thread 1 sending: " + data1);

                String received = exchanger.exchange(data1);
                System.out.println("Thread 1 received: " + received);

            } catch (InterruptedException e) {
            }
        });

        Thread thread2 = new Thread(() -> {
            try {
                Thread.sleep(2000); // Simulate work
                String data2 = "Data from Thread 2";
                System.out.println("Thread 2 sending: " + data2);

                String received = exchanger.exchange(data2);
                System.out.println("Thread 2 received: " + received);

            } catch (InterruptedException e) {
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

#### Phaser - Coordinate multiple phases

```java
import java.util.concurrent.Phaser;

class TeamWork {
    public static void main(String[] args) {
        Phaser phaser = new Phaser(3); // 3 workers

        for (int i = 1; i <= 3; i++) {
            final int workerId = i;
            new Thread(() -> {
                System.out.println("Worker " + workerId + " starting phase 1");
                try {
                    Thread.sleep(1000 * workerId);
                } catch (Exception e) {
                }
                System.out.println("Worker " + workerId + " finished phase 1");
                phaser.arriveAndAwaitAdvance(); // Wait for others

                System.out.println("Worker " + workerId + " starting phase 2");
                try {
                    Thread.sleep(500 * workerId);
                } catch (Exception e) {
                }
                System.out.println("Worker " + workerId + " finished phase 2");
                phaser.arriveAndAwaitAdvance(); // Wait for others

                System.out.println("Worker " + workerId + " ALL DONE!");
                phaser.arriveAndDeregister();

            }).start();
        }
    }
}
```

Here's the properly aligned table:

| Approach      | Pros                                | Cons                                   | When to Use                           |
|---------------|-------------------------------------|----------------------------------------|---------------------------------------|
| wait/notify   | Built-in, no extra classes          | Complex, error-prone, easy to deadlock | Legacy code, simple 1:1 communication |
| BlockingQueue | Simple, robust, handles all waiting | Fixed size, may block                  | Producer-consumer patterns            |
| Exchanger     | Perfect for 2-thread exchange       | Only 2 threads                         | Two threads swapping data             |
| Phaser        | Multiple phases, dynamic threads    | More complex                           | Multi-phase parallel tasks            |

The table is now properly aligned with consistent spacing in each column!


