### Thread

- A thread is an independent path of execution, has its own stack, shares heap memory, managed by OS scheduler, created
  via JVM native calls.
- Process → contains multiple Threads
- Thread → executes code

### Thread Creation Ways

- We can create a thread by extending Thread class
- by implementing Runnable interface.
- by implementing Callable interface.
- by using Executor Service.
- by Using Completable Future.
- In Modern java We almost never uses extending Thread class.
- There are 4 main ways.

#### Extending Thread

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Task running");
    }
}

class ThreadDemo {
    static void main() {
        MyThread t = new MyThread();
        t.start();
    }
}
```

- Blocks inheritance
- Tight coupling
- Not flexible
- Rarely used in real projects.

#### Implementing Runnable

```java
class MyTask implements Runnable {
    public void run() {
        System.out.println("Task running");
    }
}

class ThreadDemo {
    static void main() {
        Thread t = new Thread(new MyTask());
        t.start();
    }
}
```

- Separation of task & execution
- Can extend other classes
- Cleaner architecture
- Still used, but not ideal for large systems.

#### Using Lambda

```java

class ThreadDemo {
    static void main() {
        Thread t = new Thread(() -> {
            System.out.println("Task running");
        });
        t.start();
    }
}
```
- Cleaner version of Runnable.

####  Using ExecutorService

```java
class ThreadDemo {
    static void main() {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        executor.submit(() -> {
            System.out.println("Task running");
        });

        executor.shutdown();
    }
}
```
- This is how real production systems manage threads.
- Because Threads are expensive, Creating/destroying repeatedly is costly, Thread pools reuse threads, Better scalability, Better control