### Complete Guide to Executors and ExecutorService

| Category         | Method                    | What It Does                                     | Returns                  | When to Use                                    |
|------------------|---------------------------|--------------------------------------------------|--------------------------|------------------------------------------------|
| Create Executors | newFixedThreadPool(n)     | Creates thread pool with fixed number of threads | ExecutorService          | When you know exact number of concurrent tasks |
| Create Executors | newCachedThreadPool()     | Creates pool that creates new threads as needed  | ExecutorService          | When you have many short-lived tasks           |
| Create Executors | newSingleThreadExecutor() | Creates single-threaded executor                 | ExecutorService          | When tasks must execute sequentially           |
| Create Executors | newScheduledThreadPool(n) | Creates pool for delayed/scheduled tasks         | ScheduledExecutorService | When you need to schedule tasks                |
| Create Executors | newWorkStealingPool()     | Creates work-stealing thread pool                | ExecutorService          | For parallel processing (ForkJoinPool)         |
| Submit Tasks     | execute(Runnable)         | Submits task, no result                          | void                     | Fire-and-forget tasks                          |
| Submit Tasks     | submit(Runnable)          | Submits task, returns Future                     | Future<?>                | When you need to track completion              |
| Submit Tasks     | submit(Callable)          | Submits task, returns result                     | Future<T>                | When you need a result                         |
| Submit Tasks     | invokeAny(Collection)     | Submits multiple tasks, returns first result     | T                        | When you need fastest response                 |
| Submit Tasks     | invokeAll(Collection)     | Submits multiple tasks, returns all results      | List<Future<T>>          | When you need all results                      |
| Shutdown         | shutdown()                | No new tasks, completes existing                 | void                     | Graceful shutdown                              |
| Shutdown         | shutdownNow()             | Attempts to stop all tasks                       | List<Runnable>           | Forceful shutdown                              |
| Shutdown         | awaitTermination()        | Waits for termination                            | boolean                  | After shutdown, wait for completion            |
| Schedule Tasks   | schedule()                | Run task once after delay                        | ScheduledFuture<?>       | Delayed execution                              |
| Schedule Tasks   | scheduleAtFixedRate()     | Run task at fixed rate                           | ScheduledFuture<?>       | Periodic tasks (ignore execution time)         |
| Schedule Tasks   | scheduleWithFixedDelay()  | Run task with fixed delay                        | ScheduledFuture<?>       | Periodic tasks (wait after completion)         |
| Monitor          | isShutdown()              | Check if executor is shutdown                    | boolean                  | Before submitting tasks                        |
| Monitor          | isTerminated()            | Check if all tasks completed                     | boolean                  | After shutdown to verify completion            |

#### CREATING EXECUTORS - Different Types

**FixedThreadPool - Most Common**

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class FixedThreadPoolExample {
    public static void main(String[] args) {
        // Create a pool with 3 threads
        ExecutorService executor = Executors.newFixedThreadPool(3);

        System.out.println("=== Fixed Thread Pool (3 threads) ===");

        // Submit 6 tasks - they'll be queued
        for (int i = 1; i <= 6; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " started by " +
                        Thread.currentThread().getName());
                try {
                    Thread.sleep(2000); // Simulate work
                } catch (InterruptedException e) {
                }
                System.out.println("Task " + taskId + " completed by " +
                        Thread.currentThread().getName());
            });
        }

        executor.shutdown();
    }
}
```

output

```text
=== Fixed Thread Pool (3 threads) ===
Task 1 started by pool-1-thread-1
Task 2 started by pool-1-thread-2
Task 3 started by pool-1-thread-3
Task 4 started by pool-1-thread-1  (after thread1 completes)
Task 5 started by pool-1-thread-2  (after thread2 completes)
Task 6 started by pool-1-thread-3  (after thread3 completes)
```

#### CachedThreadPool - Dynamic Thread Creation

```java
public class CachedThreadPoolExample {
    public static void main(String[] args) {
        // Creates threads as needed, reuses idle threads
        ExecutorService executor = Executors.newCachedThreadPool();

        System.out.println("=== Cached Thread Pool (dynamic) ===");

        // Submit 10 quick tasks
        for (int i = 1; i <= 10; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " running on " +
                        Thread.currentThread().getName());
                try {
                    Thread.sleep(500); // Short task
                } catch (InterruptedException e) {
                }
            });
        }

        executor.shutdown();
    }
}
```

output

```text
Task 1 running on pool-1-thread-1
Task 2 running on pool-1-thread-2
Task 3 running on pool-1-thread-3
Task 4 running on pool-1-thread-4
Task 5 running on pool-1-thread-1  (thread1 reused!)
Task 6 running on pool-1-thread-2  (thread2 reused!)
```

#### SingleThreadExecutor - Sequential Execution

```java
public class SingleThreadExecutorExample {
    public static void main(String[] args) {
        // All tasks execute sequentially
        ExecutorService executor = Executors.newSingleThreadExecutor();

        System.out.println("=== Single Thread Executor (sequential) ===");

        for (int i = 1; i <= 5; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " started at " +
                        System.currentTimeMillis() % 10000);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                }
                System.out.println("Task " + taskId + " completed");
            });
        }

        executor.shutdown();
    }
}
```

output: Task run one after the other

```text
Task 1 started at 1234
Task 1 completed
Task 2 started at 2234
Task 2 completed
Task 3 started at 3234
...
```

#### ScheduledThreadPool - For Delayed/Repeated Tasks

```java
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class ScheduledThreadPoolExample {
    public static void main(String[] args) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

        System.out.println("=== Scheduled Thread Pool ===");

        // 1. Run once after 2 seconds
        scheduler.schedule(() -> {
            System.out.println("üî• One-time task executed after 2 seconds");
        }, 2, TimeUnit.SECONDS);

        // 2. Run at fixed rate (every 3 seconds) - ignores execution time
        scheduler.scheduleAtFixedRate(() -> {
            System.out.println("‚è∞ Fixed rate task at " +
                    System.currentTimeMillis() % 10000);
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            } // Task takes 1 sec
        }, 1, 3, TimeUnit.SECONDS);

        // 3. Run with fixed delay (3 seconds between completions)
        scheduler.scheduleWithFixedDelay(() -> {
            System.out.println("‚è±Ô∏è  Fixed delay task at " +
                    System.currentTimeMillis() % 10000);
            try {
                Thread.sleep(2000);
            } catch (Exception e) {
            } // Task takes 2 sec
        }, 1, 3, TimeUnit.SECONDS);

        // Let it run for 15 seconds then shutdown
        try {
            Thread.sleep(15000);
        } catch (Exception e) {
        }
        scheduler.shutdown();
    }
}
```

output

```text
=== Scheduled Thread Pool ===
‚è∞ Fixed rate task at 1234  (runs every 3 sec, regardless of execution)
‚è±Ô∏è  Fixed delay task at 1235  (waits 3 sec after completion)
üî• One-time task executed after 2 seconds
‚è∞ Fixed rate task at 4234
‚è±Ô∏è  Fixed delay task at 6235  (3 sec after previous completed)
```

#### WorkStealingPool - For Parallel Processing

```java
public class WorkStealingPoolExample {
    public static void main(String[] args) {
        // Uses all available processors
        ExecutorService executor = Executors.newWorkStealingPool();

        System.out.println("=== Work-Stealing Pool (ForkJoin) ===");

        // Process a large list in parallel
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        try {
            List<CompletableFuture<Integer>> futures = numbers.stream()
                    .map(num -> CompletableFuture.supplyAsync(() -> {
                        System.out.println(Thread.currentThread().getName() +
                                " processing " + num);
                        try {
                            Thread.sleep(1000);
                        } catch (Exception e) {
                        }
                        return num * num;
                    }, executor))
                    .collect(Collectors.toList());

            // Get all results
            for (CompletableFuture<Integer> future : futures) {
                System.out.println("Result: " + future.get());
            }
        } catch (Exception e) {
        }
    }
}
```

output:

```text
=== Work-Stealing Pool (ForkJoin) ===
ForkJoinPool-1-worker-3 processing 1
ForkJoinPool-1-worker-5 processing 2
ForkJoinPool-1-worker-7 processing 3
ForkJoinPool-1-worker-1 processing 4
ForkJoinPool-1-worker-2 processing 5
ForkJoinPool-1-worker-4 processing 6
ForkJoinPool-1-worker-6 processing 7
ForkJoinPool-1-worker-2 processing 8
ForkJoinPool-1-worker-3 processing 9
ForkJoinPool-1-worker-5 processing 10
Result: 1
Result: 4
Result: 9
Result: 16
Result: 25
Result: 36
Result: 49
Result: 64
Result: 81
Result: 100

```

### SUBMITTING TASKS - Different Ways

#### execute() vs submit() Comparison

```java
public class SubmitVsExecuteExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        System.out.println("=== execute() vs submit() ===");

        // execute() - No result, no Future
        executor.execute(() -> {
            System.out.println("execute(): Running task");
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            }
        });

        // submit(Runnable) - Returns Future<?>
        Future<?> future1 = executor.submit(() -> {
            System.out.println("submit(Runnable): Running task");
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            }
        });

        // submit(Callable) - Returns Future<T> with result
        Future<String> future2 = executor.submit(() -> {
            System.out.println("submit(Callable): Running task");
            Thread.sleep(1000);
            return "Task Result!";
        });

        try {
            // Wait for results
            System.out.println("Future1 result (null): " + future1.get());
            System.out.println("Future2 result: " + future2.get());
        } catch (Exception e) {
        }

        executor.shutdown();
    }
}
```

output

```text
=== execute() vs submit() ===
execute(): Running task
submit(Runnable): Running task
submit(Callable): Running task
Future1 result (null): null
Future2 result: Task Result!
```

#### invokeAny() - Get Fastest Response

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.Arrays;
import java.util.List;

public class InvokeAnyExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        System.out.println("=== invokeAny() - Get Fastest Response ===");

        // Simulate calling multiple servers
        List<Callable<String>> tasks = Arrays.asList(
                () -> {
                    System.out.println("Calling Server 1 (slow)...");
                    Thread.sleep(3000);
                    return "Response from Server 1";
                },
                () -> {
                    System.out.println("Calling Server 2 (fast)...");
                    Thread.sleep(1000);
                    return "Response from Server 2";
                },
                () -> {
                    System.out.println("Calling Server 3 (medium)...");
                    Thread.sleep(2000);
                    return "Response from Server 3";
                }
        );

        try {
            // Returns result from fastest server
            String result = executor.invokeAny(tasks);
            System.out.println("‚úÖ Fastest response: " + result);
        } catch (Exception e) {
            System.out.println("All servers failed!");
        }

        executor.shutdown();
    }
}
```

output:

```text
=== invokeAny() - Get Fastest Response ===
Calling Server 1 (slow)...
Calling Server 2 (fast)...
Calling Server 3 (medium)...
‚úÖ Fastest response: Response from Server 2
```

#### invokeAll() - Get All Results

```java
public class InvokeAllExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        System.out.println("=== invokeAll() - Get All Results ===");

        List<Callable<String>> tasks = Arrays.asList(
                () -> {
                    Thread.sleep(3000);
                    return "Task 1 completed";
                },
                () -> {
                    Thread.sleep(1000);
                    return "Task 2 completed";
                },
                () -> {
                    Thread.sleep(2000);
                    return "Task 3 completed";
                }
        );

        try {
            // Waits for ALL tasks to complete
            List<Future<String>> futures = executor.invokeAll(tasks);

            System.out.println("All tasks completed! Getting results:");
            for (Future<String> future : futures) {
                System.out.println("  " + future.get());
            }
        } catch (Exception e) {
        }

        executor.shutdown();
    }
}
```

output

```text
=== invokeAll() - Get All Results ===
All tasks completed! Getting results:
  Task 1 completed
  Task 2 completed
  Task 3 completed
```

### SHUTDOWN METHODS - Graceful vs Forceful

```java
public class ShutdownExamples {
    public static void main(String[] args) {
        System.out.println("=== Shutdown Methods ===");

        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Submit some long-running tasks
        for (int i = 1; i <= 5; i++) {
            int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("Task " + taskId + " started");
                    Thread.sleep(taskId * 2000); // Different durations
                    System.out.println("Task " + taskId + " completed");
                } catch (InterruptedException e) {
                    System.out.println("Task " + taskId + " was interrupted!");
                }
            });
        }

        // Give tasks time to start
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
        }

        // Demonstrate shutdown
        System.out.println("\n1. Calling shutdown() - no new tasks accepted");
        executor.shutdown(); // No new tasks, but existing continue

        try {
            // This would throw RejectedExecutionException
            // executor.submit(() -> System.out.println("New task"));
        } catch (Exception e) {
            System.out.println("   Can't submit new tasks after shutdown");
        }

        // Demonstrate awaitTermination
        try {
            System.out.println("\n2. Waiting for tasks to complete...");
            boolean terminated = executor.awaitTermination(5, TimeUnit.SECONDS);

            if (!terminated) {
                System.out.println("   Tasks didn't complete in time!");
                System.out.println("\n3. Calling shutdownNow() - force stop");
                List<Runnable> unfinished = executor.shutdownNow();
                System.out.println("   " + unfinished.size() + " tasks were cancelled");
            }
        } catch (InterruptedException e) {
        }
    }
}
```

output

```text
=== Shutdown Methods ===
Task 1 started
Task 2 started
Task 3 started

1. Calling shutdown() - no new tasks accepted
   Can't submit new tasks after shutdown

2. Waiting for tasks to complete...
Task 1 completed
Task 4 started
Task 5 started
   Tasks didn't complete in time!

3. Calling shutdownNow() - force stop
Task 4 was interrupted!
Task 5 was interrupted!
   2 tasks were cancelled
```

## REAL-WORLD EXAMPLE: Web Crawler

```java
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class WebCrawler {
    private final ExecutorService executor;
    private final Set<String> visitedUrls = ConcurrentHashMap.newKeySet();
    private final Queue<String> urlQueue = new ConcurrentLinkedQueue<>();
    private final AtomicInteger activeTasks = new AtomicInteger(0);

    public WebCrawler(int threadCount) {
        this.executor = Executors.newFixedThreadPool(threadCount);
    }

    public void startCrawling(String seedUrl) {
        System.out.println("üöÄ Starting web crawler with seed: " + seedUrl);
        urlQueue.add(seedUrl);

        // Submit initial batch of tasks
        for (int i = 0; i < 3; i++) {
            submitNextCrawl();
        }

        // Monitor and shutdown
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        monitor.scheduleAtFixedRate(() -> {
            if (urlQueue.isEmpty() && activeTasks.get() == 0) {
                System.out.println("‚úÖ Crawling complete!");
                shutdown();
                monitor.shutdown();
            } else {
                System.out.println("üìä Queue: " + urlQueue.size() +
                        ", Active: " + activeTasks.get() +
                        ", Visited: " + visitedUrls.size());
            }
        }, 2, 2, TimeUnit.SECONDS);
    }

    private void submitNextCrawl() {
        String url = urlQueue.poll();
        if (url != null && !visitedUrls.contains(url)) {
            visitedUrls.add(url);
            activeTasks.incrementAndGet();

            CompletableFuture.supplyAsync(() -> crawlUrl(url), executor)
                    .thenAccept(this::processLinks)
                    .whenComplete((result, error) -> {
                        activeTasks.decrementAndGet();
                        if (activeTasks.get() < 3 && !urlQueue.isEmpty()) {
                            submitNextCrawl(); // Keep pool busy
                        }
                    });
        }
    }

    private List<String> crawlUrl(String url) {
        System.out.println("üï∑Ô∏è Crawling: " + url + " on " +
                Thread.currentThread().getName());
        try {
            Thread.sleep(1000); // Simulate network delay

            // Simulate finding links
            return Arrays.asList(
                    url + "/page1",
                    url + "/page2",
                    url + "/page3"
            );
        } catch (Exception e) {
            return Collections.emptyList();
        }
    }

    private void processLinks(List<String> links) {
        for (String link : links) {
            if (!visitedUrls.contains(link) && !urlQueue.contains(link)) {
                urlQueue.add(link);
                if (activeTasks.get() < 5) { // Maintain concurrency
                    submitNextCrawl();
                }
            }
        }
    }

    private void shutdown() {
        executor.shutdown();
        try {
            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executor.shutdownNow();
        }
    }

    public static void main(String[] args) {
        WebCrawler crawler = new WebCrawler(3);
        crawler.startCrawling("https://example.com");
    }
}
```

## REAL-WORLD EXAMPLE: Banking Transaction System

```java
import java.util.concurrent.*;
import java.util.*;

class BankingSystem {
    private final ExecutorService transactionExecutor;
    private final ScheduledExecutorService auditScheduler;
    private final Map<String, Double> accounts = new ConcurrentHashMap<>();
    private final Queue<Transaction> auditLog = new ConcurrentLinkedQueue<>();

    public BankingSystem() {
        // Process transactions with 5 threads
        this.transactionExecutor = Executors.newFixedThreadPool(5);

        // Schedule audits and reports
        this.auditScheduler = Executors.newScheduledThreadPool(2);

        // Initialize accounts
        accounts.put("ACC001", 5000.0);
        accounts.put("ACC002", 3000.0);
        accounts.put("ACC003", 10000.0);
    }

    public void start() {
        System.out.println("üè¶ Banking System Started");

        // Schedule daily audit at fixed rate
        auditScheduler.scheduleAtFixedRate(() -> {
            performAudit();
        }, 1, 10, TimeUnit.SECONDS);

        // Generate reports every 15 seconds
        auditScheduler.scheduleWithFixedDelay(() -> {
            generateReport();
        }, 5, 15, TimeUnit.SECONDS);

        // Schedule system health check
        auditScheduler.schedule(() -> {
            System.out.println("ü©∫ Running system health check...");
            checkSystemHealth();
        }, 3, TimeUnit.SECONDS);
    }

    public Future<TransactionResult> transfer(String fromAcc, String toAcc,
                                              double amount) {
        return transactionExecutor.submit(() -> {
            String transactionId = UUID.randomUUID().toString();
            System.out.println("üí∞ Processing transfer: $" + amount +
                    " from " + fromAcc + " to " + toAcc);

            // Simulate processing time
            Thread.sleep(1000);

            synchronized (accounts) {
                double fromBalance = accounts.getOrDefault(fromAcc, 0.0);
                double toBalance = accounts.getOrDefault(toAcc, 0.0);

                if (fromBalance >= amount) {
                    accounts.put(fromAcc, fromBalance - amount);
                    accounts.put(toAcc, toBalance + amount);

                    Transaction tx = new Transaction(transactionId, fromAcc,
                            toAcc, amount, "SUCCESS");
                    auditLog.add(tx);

                    System.out.println("‚úÖ Transfer successful: " + transactionId);
                    return new TransactionResult(true, transactionId,
                            accounts.get(fromAcc));
                } else {
                    Transaction tx = new Transaction(transactionId, fromAcc,
                            toAcc, amount, "FAILED");
                    auditLog.add(tx);

                    System.out.println("‚ùå Transfer failed: Insufficient funds");
                    return new TransactionResult(false, transactionId,
                            fromBalance);
                }
            }
        });
    }

    private void performAudit() {
        System.out.println("\nüîç Performing audit...");
        System.out.println("   Total transactions: " + auditLog.size());
        System.out.println("   Account balances:");
        accounts.forEach((acc, bal) ->
                System.out.println("     " + acc + ": $" + bal));
    }

    private void generateReport() {
        System.out.println("\nüìä Generating daily report...");
        long successCount = auditLog.stream()
                .filter(tx -> "SUCCESS".equals(tx.status))
                .count();
        long failedCount = auditLog.stream()
                .filter(tx -> "FAILED".equals(tx.status))
                .count();

        System.out.println("   Successful: " + successCount);
        System.out.println("   Failed: " + failedCount);
        System.out.println("   Total volume: $" +
                auditLog.stream().mapToDouble(tx -> tx.amount).sum());
    }

    private void checkSystemHealth() {
        System.out.println("\nü©∫ Health Check Results:");
        System.out.println("   Transaction Executor:");
        System.out.println("     Active threads: " +
                ((ThreadPoolExecutor) transactionExecutor).getActiveCount());
        System.out.println("     Queue size: " +
                ((ThreadPoolExecutor) transactionExecutor).getQueue().size());
        System.out.println("     Completed tasks: " +
                ((ThreadPoolExecutor) transactionExecutor).getCompletedTaskCount());
    }

    public void shutdown() {
        System.out.println("\nüõë Shutting down banking system...");

        // Graceful shutdown
        transactionExecutor.shutdown();
        auditScheduler.shutdown();

        try {
            if (!transactionExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                transactionExecutor.shutdownNow();
            }
            if (!auditScheduler.awaitTermination(2, TimeUnit.SECONDS)) {
                auditScheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            transactionExecutor.shutdownNow();
            auditScheduler.shutdownNow();
        }

        System.out.println("üëã Banking system shutdown complete");
    }

    // Helper classes
    static class Transaction {
        String id, from, to, status;
        double amount;

        Transaction(String id, String from, String to, double amount, String status) {
            this.id = id;
            this.from = from;
            this.to = to;
            this.amount = amount;
            this.status = status;
        }
    }

    static class TransactionResult {
        boolean success;
        String transactionId;
        double newBalance;

        TransactionResult(boolean success, String transactionId, double newBalance) {
            this.success = success;
            this.transactionId = transactionId;
            this.newBalance = newBalance;
        }
    }

    public static void main(String[] args) throws Exception {
        BankingSystem bank = new BankingSystem();
        bank.start();

        // Simulate multiple transactions
        List<Future<TransactionResult>> futures = new ArrayList<>();

        // Submit 10 random transfers
        for (int i = 0; i < 10; i++) {
            String from = "ACC00" + (1 + (int) (Math.random() * 3));
            String to = "ACC00" + (1 + (int) (Math.random() * 3));
            double amount = 500 + (int) (Math.random() * 1000);

            futures.add(bank.transfer(from, to, amount));
            Thread.sleep(500);
        }

        // Wait for all transfers to complete
        for (Future<TransactionResult> future : futures) {
            TransactionResult result = future.get();
            if (!result.success) {
                System.out.println("   Failed tx: " + result.transactionId);
            }
        }

        // Let audits run a bit
        Thread.sleep(15000);

        bank.shutdown();
    }
}
```

### Quick Reference Card

| Method                    | Use Case                               | Example                         |
|---------------------------|----------------------------------------|---------------------------------|
| newFixedThreadPool(5)     | Known number of concurrent tasks       | Web server handling requests    |
| newCachedThreadPool()     | Many short-lived tasks                 | Processing image thumbnails     |
| newSingleThreadExecutor() | Sequential processing                  | Writing logs to file            |
| newScheduledThreadPool(2) | Periodic tasks                         | Database cleanup, health checks |
| newWorkStealingPool()     | Parallel processing                    | Large data processing           |
| submit(Callable)          | Need result back                       | API calls, calculations         |
| invokeAny()               | Need fastest response                  | Microservice calls, redundancy  |
| invokeAll()               | Need all responses                     | Parallel data fetching          |
| scheduleAtFixedRate()     | Fixed interval regardless of execution | Metrics collection              |
| scheduleWithFixedDelay()  | Fixed delay between completions        | Report generation               |
