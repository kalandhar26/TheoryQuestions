## Fork Join Pool

| Category        | Method                 | What It Does                              | Returns         | When to Use                         |
|-----------------|------------------------|-------------------------------------------|-----------------|-------------------------------------|
| Create Pool     | ForkJoinPool()         | Creates pool with parallelism = CPU cores | ForkJoinPool    | Default for most cases              |
| Create Pool     | ForkJoinPool(n)        | Creates pool with n threads               | ForkJoinPool    | When you need specific parallelism  |
| Create Pool     | commonPool()           | Returns shared common pool                | ForkJoinPool    | For most parallel stream operations |
| Submit Tasks    | submit(ForkJoinTask)   | Submits task for async execution          | ForkJoinTask<T> | When you need result                |
| Submit Tasks    | execute(ForkJoinTask)  | Submits task, no result                   | void            | Fire-and-forget tasks               |
| Submit Tasks    | invoke(ForkJoinTask)   | Submits and waits for result              | T               | When you need result immediately    |
| Task Types      | RecursiveTask          | Task that returns a value                 | T               | When computation returns result     |
| Task Types      | RecursiveAction        | Task that returns nothing                 | Void            | When computation modifies data      |
| Task Types      | CountedCompleter       | Task with completion callbacks            | T               | Complex task dependencies           |
| Task Operations | fork()                 | Forks task to run asynchronously          | ForkJoinTask<T> | Split work into subtasks            |
| Task Operations | join()                 | Waits for task result                     | T               | Combine results from subtasks       |
| Task Operations | invokeAll()            | Forks multiple tasks and waits            | void            | Fork multiple subtasks at once      |
| Pool Management | getParallelism()       | Gets number of threads                    | int             | Check pool configuration            |
| Pool Management | getPoolSize()          | Gets current thread count                 | int             | Monitor pool usage                  |
| Pool Management | getActiveThreadCount() | Gets active threads                       | int             | Monitor activity                    |
| Pool Management | getStealCount()        | Gets work stealing count                  | long            | Measure load balancing              |
| Shutdown        | shutdown()             | No new tasks, completes existing          | void            | Graceful shutdown                   |
| Shutdown        | shutdownNow()          | Attempts to stop tasks                    | List<Runnable>  | Forceful shutdown                   |
| Shutdown        | awaitTermination()     | Waits for termination                     | boolean         | After shutdown                      |

### UNDERSTANDING FORK/JOIN - The Concept

- Think of Fork/Join like a restaurant kitchen:
- Chef (Main Thread) receives a large order
- Forks the work to multiple cooks (subtasks)
- Cooks work in parallel
- Joins the prepared dishes into complete meal

#### RECURSIVETASK - Tasks That Return Values

**Sum of Array**

```java
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ThreadLocalRandom;

class SumTask extends RecursiveTask<Long> {
    private static final int THRESHOLD = 1000; // Minimum size to process directly
    private final int[] array;
    private final int start;
    private final int end;

    public SumTask(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;

        // If small enough, compute directly
        if (length <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            System.out.println(Thread.currentThread().getName() +
                    " computed sum from " + start + " to " + end +
                    " = " + sum);
            return sum;
        }

        // Otherwise, split into two subtasks
        int mid = start + length / 2;

        System.out.println(Thread.currentThread().getName() +
                " splitting [" + start + "-" + end + "] into " +
                "[" + start + "-" + mid + "] and [" + mid + "-" + end + "]");

        SumTask leftTask = new SumTask(array, start, mid);
        SumTask rightTask = new SumTask(array, mid, end);

        // Fork both tasks (run in parallel)
        leftTask.fork();
        rightTask.fork();

        // Join results (wait for completion)
        long leftResult = leftTask.join();
        long rightResult = rightTask.join();

        // Combine results
        long result = leftResult + rightResult;
        System.out.println(Thread.currentThread().getName() +
                " combined [" + start + "-" + end + "] = " + result);

        return result;
    }
}

public class ForkJoinSumExample {
    public static void main(String[] args) {
        // Create large array
        int[] array = new int[10_000];
        for (int i = 0; i < array.length; i++) {
            array[i] = ThreadLocalRandom.current().nextInt(100);
        }

        // Create ForkJoinPool with parallelism = number of processors
        ForkJoinPool pool = new ForkJoinPool(); // Uses all CPU cores
        // Or specify: new ForkJoinPool(4) for 4 threads

        System.out.println("=== Array Sum Using Fork/Join ===");
        System.out.println("Pool parallelism: " + pool.getParallelism() + " threads");

        // Create and invoke main task
        SumTask task = new SumTask(array, 0, array.length);
        long result = pool.invoke(task); // Submit and wait for result

        // Verify result
        long expected = 0;
        for (int num : array) expected += num;

        System.out.println("\nâœ… Fork/Join Result: " + result);
        System.out.println("âœ… Expected Result: " + expected);
        System.out.println("âœ… Match: " + (result == expected));

        // Pool statistics
        System.out.println("\nðŸ“Š Pool Statistics:");
        System.out.println("  Steal Count: " + pool.getStealCount());
        System.out.println("  Active Threads: " + pool.getActiveThreadCount());
        System.out.println("  Pool Size: " + pool.getPoolSize());

        pool.shutdown();
    }
}
```

output

```text
=== Array Sum Using Fork/Join ===
Pool parallelism: 8 threads
ForkJoinPool-1-worker-1 splitting [0-10000] into [0-5000] and [5000-10000]
ForkJoinPool-1-worker-2 splitting [0-5000] into [0-2500] and [2500-5000]
ForkJoinPool-1-worker-3 splitting [5000-10000] into [5000-7500] and [7500-10000]
...
ForkJoinPool-1-worker-4 computed sum from 0-1000 = 49872
ForkJoinPool-1-worker-5 computed sum from 1000-2000 = 50231
...

âœ… Fork/Join Result: 4972834
âœ… Expected Result: 4972834
âœ… Match: true

ðŸ“Š Pool Statistics:
  Steal Count: 12
  Active Threads: 4
  Pool Size: 8
```

#### Finding Maximum in Array

```java
class MaxFindingTask extends RecursiveTask<Integer> {
    private static final int THRESHOLD = 1000;
    private final int[] array;
    private final int start;
    private final int end;

    public MaxFindingTask(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int length = end - start;

        if (length <= THRESHOLD) {
            int max = Integer.MIN_VALUE;
            for (int i = start; i < end; i++) {
                max = Math.max(max, array[i]);
            }
            return max;
        }

        int mid = start + length / 2;

        MaxFindingTask leftTask = new MaxFindingTask(array, start, mid);
        MaxFindingTask rightTask = new MaxFindingTask(array, mid, end);

        // Better: Use invokeAll for both tasks
        invokeAll(leftTask, rightTask);

        return Math.max(leftTask.join(), rightTask.join());
    }
}

public class FindMaxExample {
    public static void main(String[] args) {
        int[] numbers = new int[1_000_000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = (int) (Math.random() * 1_000_000);
        }

        ForkJoinPool pool = ForkJoinPool.commonPool(); // Use common pool

        MaxFindingTask task = new MaxFindingTask(numbers, 0, numbers.length);
        int max = pool.invoke(task);

        System.out.println("Maximum value: " + max);

        // Verify with sequential search
        int expected = Integer.MIN_VALUE;
        for (int num : numbers) expected = Math.max(expected, num);
        System.out.println("Verified max: " + expected);
    }
}
```

output

```text

```

#### RECURSIVEACTION - Tasks That Don't Return Values

**Parallel Array Sorting**

```java
import java.util.concurrent.RecursiveAction;

class ParallelQuickSort extends RecursiveAction {
    private static final int THRESHOLD = 1000;
    private final int[] array;
    private final int left;
    private final int right;

    public ParallelQuickSort(int[] array, int left, int right) {
        this.array = array;
        this.left = left;
        this.right = right;
    }

    @Override
    protected void compute() {
        if (right - left < THRESHOLD) {
            // Sequential sort for small arrays
            sequentialSort(array, left, right);
            return;
        }

        // Partition the array
        int pivot = partition(array, left, right);

        // Fork subtasks for both partitions
        ParallelQuickSort leftTask = new ParallelQuickSort(array, left, pivot - 1);
        ParallelQuickSort rightTask = new ParallelQuickSort(array, pivot + 1, right);

        // Execute both in parallel
        invokeAll(leftTask, rightTask);
    }

    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return i + 1;
    }

    private void sequentialSort(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

public class ParallelSortExample {
    public static void main(String[] args) {
        int size = 100_000;
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = (int) (Math.random() * size);
        }

        int[] arrayCopy = array.clone(); // For verification

        ForkJoinPool pool = new ForkJoinPool();

        System.out.println("=== Parallel QuickSort ===");
        System.out.println("Sorting " + size + " elements...");

        long start = System.currentTimeMillis();
        pool.invoke(new ParallelQuickSort(array, 0, array.length - 1));
        long end = System.currentTimeMillis();

        System.out.println("âœ… Parallel sort completed in " + (end - start) + "ms");

        // Verify sorting
        java.util.Arrays.sort(arrayCopy);
        boolean sorted = java.util.Arrays.equals(array, arrayCopy);
        System.out.println("âœ… Array correctly sorted: " + sorted);

        pool.shutdown();
    }
}
```

output

```text

```

#### COUNTEDCOMPLETER - Advanced Tasks with Callbacks

```java
import java.util.concurrent.CountedCompleter;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.atomic.AtomicInteger;

class WordCounter extends CountedCompleter<Integer> {
    private static final int THRESHOLD = 1000;
    private final String[] words;
    private final int start;
    private final int end;
    private final String searchTerm;
    private AtomicInteger result = new AtomicInteger(0);

    // Constructor for root task
    public WordCounter(String[] words, String searchTerm) {
        this(null, words, 0, words.length, searchTerm);
    }

    // Constructor for subtasks
    public WordCounter(CountedCompleter<?> completer, String[] words,
                       int start, int end, String searchTerm) {
        super(completer);
        this.words = words;
        this.start = start;
        this.end = end;
        this.searchTerm = searchTerm;
    }

    @Override
    public void compute() {
        int length = end - start;

        if (length <= THRESHOLD) {
            // Direct computation
            int count = 0;
            for (int i = start; i < end; i++) {
                if (words[i].contains(searchTerm)) {
                    count++;
                }
            }

            // Add to result and complete
            result.addAndGet(count);
            tryComplete();
            return;
        }

        // Split into subtasks
        int mid = start + length / 2;
        int pendingCount = 2; // We'll have 2 subtasks

        setPendingCount(pendingCount);

        WordCounter left = new WordCounter(this, words, start, mid, searchTerm);
        WordCounter right = new WordCounter(this, words, mid, end, searchTerm);

        left.fork();
        right.fork();

        // Don't call tryComplete() - it will be called when subtasks complete
    }

    @Override
    public Integer getRawResult() {
        return result.get();
    }
}

public class CountedCompleterExample {
    public static void main(String[] args) {
        // Create sample data
        String[] words = new String[100_000];
        for (int i = 0; i < words.length; i++) {
            words[i] = "word" + i + (Math.random() > 0.5 ? "test" : "");
        }

        ForkJoinPool pool = ForkJoinPool.commonPool();

        System.out.println("=== CountedCompleter Example: Word Search ===");

        WordCounter counter = new WordCounter(words, "test");
        int count = pool.invoke(counter);

        System.out.println("âœ… Found " + count + " words containing 'test'");

        // Verify
        int expected = 0;
        for (String word : words) {
            if (word.contains("test")) expected++;
        }
        System.out.println("âœ… Expected count: " + expected);
    }
}
```

output

```text

```

### REAL-WORLD EXAMPLE: Image Processing Pipeline

```java
import java.awt.image.BufferedImage;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;
import javax.imageio.ImageIO;
import java.io.File;

class ImageProcessingTask extends RecursiveAction {
    private static final int THRESHOLD = 1000; // Pixels per task
    private final int[] pixels;
    private final int start;
    private final int end;
    private final int width;

    public ImageProcessingTask(int[] pixels, int start, int end, int width) {
        this.pixels = pixels;
        this.start = start;
        this.end = end;
        this.width = width;
    }

    @Override
    protected void compute() {
        int length = end - start;

        if (length <= THRESHOLD) {
            // Apply filters to pixel region
            applyFilters();
            return;
        }

        // Split image into regions
        int mid = start + length / 2;

        ImageProcessingTask left = new ImageProcessingTask(pixels, start, mid, width);
        ImageProcessingTask right = new ImageProcessingTask(pixels, mid, end, width);

        invokeAll(left, right);
    }

    private void applyFilters() {
        for (int i = start; i < end; i++) {
            int x = i % width;
            int y = i / width;

            int pixel = pixels[i];

            // Apply multiple filters
            pixel = applyGrayscale(pixel);
            pixel = applySepia(pixel);
            pixel = adjustContrast(pixel, 1.2);

            pixels[i] = pixel;
        }
    }

    private int applyGrayscale(int pixel) {
        int a = (pixel >> 24) & 0xff;
        int r = (pixel >> 16) & 0xff;
        int g = (pixel >> 8) & 0xff;
        int b = pixel & 0xff;

        int gray = (r + g + b) / 3;
        return (a << 24) | (gray << 16) | (gray << 8) | gray;
    }

    private int applySepia(int pixel) {
        int a = (pixel >> 24) & 0xff;
        int r = (pixel >> 16) & 0xff;
        int g = (pixel >> 8) & 0xff;
        int b = pixel & 0xff;

        int tr = (int) (0.393 * r + 0.769 * g + 0.189 * b);
        int tg = (int) (0.349 * r + 0.686 * g + 0.168 * b);
        int tb = (int) (0.272 * r + 0.534 * g + 0.131 * b);

        tr = Math.min(255, tr);
        tg = Math.min(255, tg);
        tb = Math.min(255, tb);

        return (a << 24) | (tr << 16) | (tg << 8) | tb;
    }

    private int adjustContrast(int pixel, double factor) {
        int a = (pixel >> 24) & 0xff;
        int r = (pixel >> 16) & 0xff;
        int g = (pixel >> 8) & 0xff;
        int b = pixel & 0xff;

        r = (int) Math.min(255, Math.max(0, ((r - 128) * factor + 128)));
        g = (int) Math.min(255, Math.max(0, ((g - 128) * factor + 128)));
        b = (int) Math.min(255, Math.max(0, ((b - 128) * factor + 128)));

        return (a << 24) | (r << 16) | (g << 8) | b;
    }
}

public class ImageProcessor {
    private final ForkJoinPool pool;

    public ImageProcessor() {
        this.pool = new ForkJoinPool();
    }

    public BufferedImage processImage(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        int[] pixels = image.getRGB(0, 0, width, height, null, 0, width);

        System.out.println("ðŸŽ¨ Processing image: " + width + "x" + height +
                " = " + pixels.length + " pixels");
        System.out.println("ðŸ“Š Using " + pool.getParallelism() + " threads");

        long start = System.currentTimeMillis();

        // Create and invoke processing task
        ImageProcessingTask task = new ImageProcessingTask(pixels, 0, pixels.length, width);
        pool.invoke(task);

        long end = System.currentTimeMillis();

        System.out.println("âœ… Processing completed in " + (end - start) + "ms");
        System.out.println("ðŸ”„ Work stealing count: " + pool.getStealCount());

        // Create result image
        BufferedImage result = new BufferedImage(width, height, image.getType());
        result.setRGB(0, 0, width, height, pixels, 0, width);

        return result;
    }

    public void shutdown() {
        pool.shutdown();
    }

    public static void main(String[] args) {
        try {
            // Create sample image (in real app, load from file)
            BufferedImage image = new BufferedImage(1920, 1080, BufferedImage.TYPE_INT_RGB);

            ImageProcessor processor = new ImageProcessor();
            BufferedImage processed = processor.processImage(image);

            System.out.println("ðŸŽ¯ Image processed successfully!");

            // Save processed image
            // ImageIO.write(processed, "jpg", new File("processed.jpg"));

            processor.shutdown();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### WORK STEALING IN ACTION

```java
class WorkStealingDemo {
    public static void main(String[] args) {
        System.out.println("=== Work Stealing Demonstration ===\n");

        ForkJoinPool pool = new ForkJoinPool(4); // 4 threads

        // Create tasks of different sizes
        RecursiveAction task1 = new VariableSizeTask("Task-A", 1000); // Large
        RecursiveAction task2 = new VariableSizeTask("Task-B", 100);  // Small
        RecursiveAction task3 = new VariableSizeTask("Task-C", 200);  // Medium
        RecursiveAction task4 = new VariableSizeTask("Task-D", 800);  // Large

        System.out.println("Submitting tasks...\n");

        pool.execute(task1);
        pool.execute(task2);
        pool.execute(task3);
        pool.execute(task4);

        // Monitor work stealing
        for (int i = 0; i < 5; i++) {
            try {
                Thread.sleep(500);
            } catch (Exception e) {
            }
            System.out.println("ðŸ“Š Steal count: " + pool.getStealCount());
        }

        pool.shutdown();
    }

    static class VariableSizeTask extends RecursiveAction {
        private final String name;
        private final int size;

        VariableSizeTask(String name, int size) {
            this.name = name;
            this.size = size;
        }

        @Override
        protected void compute() {
            if (size > 500) {
                // Split large tasks
                int half = size / 2;
                VariableSizeTask left = new VariableSizeTask(name + "-L", half);
                VariableSizeTask right = new VariableSizeTask(name + "-R", size - half);

                System.out.println(Thread.currentThread().getName() +
                        " splitting " + name + " into subtasks");

                invokeAll(left, right);
            } else {
                // Do work
                System.out.println(Thread.currentThread().getName() +
                        " working on " + name + " (size=" + size + ")");

                try {
                    Thread.sleep(size);
                } catch (Exception e) {
                }

                System.out.println(Thread.currentThread().getName() +
                        " completed " + name);
            }
        }
    }
}
```

output

```text
Submitting tasks...

ForkJoinPool-1-worker-1 splitting Task-A into subtasks
ForkJoinPool-1-worker-2 working on Task-B (size=100)
ForkJoinPool-1-worker-3 working on Task-C (size=200)
ForkJoinPool-1-worker-4 splitting Task-D into subtasks
ForkJoinPool-1-worker-2 completed Task-B
ForkJoinPool-1-worker-2 steals Task-A-L from worker-1's queue
ForkJoinPool-1-worker-2 working on Task-A-L (size=250)
...
```

### COMPARISON: ForkJoinPool vs ExecutorService

```java
public class ComparisonDemo {
    public static void main(String[] args) {
        System.out.println("=== ForkJoinPool vs ExecutorService ===\n");

        // Task: Sum of 10 million numbers
        int[] numbers = new int[10_000_000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = (int) (Math.random() * 100);
        }

        // 1. Sequential
        long start = System.currentTimeMillis();
        long sum1 = 0;
        for (int num : numbers) sum1 += num;
        long time1 = System.currentTimeMillis() - start;

        // 2. ExecutorService (Fixed Thread Pool)
        start = System.currentTimeMillis();
        ExecutorService executor = Executors.newFixedThreadPool(4);
        // ... implementation using Callable and Future
        long time2 = System.currentTimeMillis() - start;
        executor.shutdown();

        // 3. ForkJoinPool
        start = System.currentTimeMillis();
        ForkJoinPool forkJoinPool = new ForkJoinPool(4);
        long sum3 = forkJoinPool.invoke(new SumTask(numbers, 0, numbers.length));
        long time3 = System.currentTimeMillis() - start;
        forkJoinPool.shutdown();

        System.out.println("ðŸ“Š Performance Comparison:");
        System.out.println("  Sequential: " + time1 + "ms");
        System.out.println("  ExecutorService: " + time2 + "ms");
        System.out.println("  ForkJoinPool: " + time3 + "ms");
        System.out.println("\nâœ… All sums equal: " + (sum1 == sum3));
    }
}
```

| Aspect            | ForkJoinPool                                   | ExecutorService                   |
|-------------------|------------------------------------------------|-----------------------------------|
| Design Philosophy | Work-stealing, divide-and-conquer              | General purpose task execution    |
| Best For          | Recursive, parallelizable tasks                | Independent tasks, I/O operations |
| Task Type         | ForkJoinTask (RecursiveTask / RecursiveAction) | Runnable, Callable                |
| Work Stealing     | Yes â€“ idle threads steal from busy queues      | No â€“ fixed task queue assignment  |
| Parallelism       | Automatically utilizes all CPU cores           | Configurable thread count         |
| Common Use        | Parallel streams, recursive algorithms         | Web servers, database operations  |

#### Use ForkJoinPool When:

- The problem can be recursively divided (divide and conquer)
- Tasks are CPU-intensive
- You want automatic load balancing via work-stealing
- You are implementing parallel algorithms (sorting, searching, aggregation)

#### Avoid ForkJoinPool When:

- Tasks are I/O-bound (use ExecutorService with a cached thread pool instead)
- Tasks are very small (overhead outweighs benefit)
- Tasks depend heavily on external systems (DB, network, file system)
- You donâ€™t have natural task splitting