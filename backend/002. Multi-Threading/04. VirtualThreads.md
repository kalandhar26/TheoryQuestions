### Virtual Threads

- Virtual threads, introduced as a preview in Java 19 and finalized in Java 21 (JEP 444), represent the most significant
  change to Java's concurrency model since the language's inception . They are lightweight threads managed by the JVM
  rather than the operating system, enabling developers to write simple synchronous code that scales like asynchronous
  code .
- Think of virtual threads like virtual memory: just as virtual memory maps to physical RAM, many virtual threads map to
  a small number of platform (OS) threads

#### Platform Threads vs Virtual Threads: The Core Difference

| Feature        | Platform Threads            | Virtual Threads                                            |
|----------------|-----------------------------|------------------------------------------------------------|
| Management     | 1:1 mapping with OS threads | M:N mapping (many virtual threads to few platform threads) |
| Creation Cost  | ~1‚Äì2 MB stack memory        | ~1‚Äì2 KB stack memory                                       |
| Max Count      | Thousands (limited by OS)   | Millions (limited by heap)                                 |
| Scheduling     | By OS kernel                | By JVM                                                     |
| Stack Location | Native memory               | Heap memory (GC-managed)                                   |
| Context Switch | Expensive (syscall)         | Cheap (JVM-level)                                          |
| Best For       | CPU-intensive tasks         | I/O-bound tasks                                            |

```text
Platform Threads (Traditional):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Platform Thread ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   OS Thread 1   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Platform Thread ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   OS Thread 2   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    (1:1 mapping)

Virtual Threads (Modern):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     
‚îÇ Virtual Thread 1‚îÇ‚îÄ‚îê   
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Virtual Thread 2‚îÇ‚îÄ‚îº‚îÄ‚îÄ‚ñ∂‚îÇ Platform Thread ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ   ‚îÇ  (Carrier)      ‚îÇ
‚îÇ Virtual Thread 3‚îÇ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§          ‚îÇ
‚îÇ Virtual Thread 4‚îÇ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ   ‚îÇ   OS    ‚îÇ
‚îÇ Virtual Thread 5‚îÇ‚îÄ‚îº‚îÄ‚îÄ‚ñ∂‚îÇ Thread 1‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ Virtual Thread 6‚îÇ‚îÄ‚îò   
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     (M:N mapping)
```

- Virtual threads are mounted on platform threads (carriers) which map to OS threads

#### How Virtual Threads Work?

**The Magic: Mounting and Unmounting**

- When a virtual thread executes a blocking operation (like I/O), it is unmounted from its carrier platform thread,
  allowing that carrier to execute other virtual threads.

```text
Timeline:
Time ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫

Carrier Thread 1:
‚îú‚îÄ Virtual A (running) ‚îÄ‚îÄ‚îê
‚îú‚îÄ Virtual A (blocked) ‚îÄ‚îÄ‚îº‚îÄ Virtual B (running) ‚îÄ‚îÄ‚îê
‚îú‚îÄ Virtual A (resumed) ‚îÄ‚îÄ‚îº‚îÄ Virtual B (blocked) ‚îÄ‚îÄ‚îº‚îÄ Virtual C (running) ‚îÄ‚îÄ‚ñ∫

Carrier Thread 2:
‚îú‚îÄ Virtual D (running) ‚îÄ‚îÄ‚îê
‚îú‚îÄ Virtual D (blocked) ‚îÄ‚îÄ‚îº‚îÄ Virtual E (running) ‚îÄ‚îÄ‚îê
                         ‚îî‚îÄ Virtual D (resumed) ‚îÄ‚îÄ‚îº‚îÄ Virtual F (running) ‚îÄ‚îÄ‚ñ∫

Legend: ‚îÄ‚îÄ‚ñ∫ active execution   ‚îÄ‚îÄ‚îê waiting/blocked   ‚îÄ‚îÄ‚îº‚îÄ context switch
```

- Blocking becomes cheap with virtual threads. When a thread blocks on I/O, it simply gets parked, and the carrier
  thread moves on to execute another virtual thread

#### Creating Virtual Threads: Four Ways

- Java provides multiple APIs to create virtual threads, all built on the familiar Thread class

##### Method 1 (Simplest)

**Thread.startVirtualThread()**

```java
public class CreateVirtualThreads {
    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            System.out.println("Hello from " + Thread.currentThread());
        };

        // Create and start immediately
        Thread thread = Thread.startVirtualThread(task);
        thread.join(); // Wait for completion
    }
}
```

##### Method 2 (Builder Pattern)

**Thread.ofVirtual().start()**

```java
public class BuilderPatternExample {
    public static void main(String[] args) throws InterruptedException {
        // Create with custom name
        Thread thread = Thread.ofVirtual()
                .name("my-virtual-thread")
                .start(() -> {
                    System.out.println("Running on: " + Thread.currentThread());
                    try {
                        Thread.sleep(1000); // Blocking is cheap!
                    } catch (InterruptedException e) {
                    }
                });

        thread.join();

        // Create unstarted, then start later
        Thread unstarted = Thread.ofVirtual()
                .name("lazy-thread")
                .unstarted(() -> System.out.println("Started later"));
        unstarted.start();
        unstarted.join();
    }
}
```

##### Method 3 : ThreadFactory for repeated Creation

```java
import java.util.concurrent.ThreadFactory;

public class ThreadFactoryExample {
    public static void main(String[] args) {
        // Create factory for named virtual threads
        ThreadFactory factory = Thread.ofVirtual()
                .name("worker-", 0)  // Creates worker-0, worker-1, etc.
                .factory();

        // Use factory to create threads
        Thread t1 = factory.newThread(() -> {
            System.out.println("First worker: " + Thread.currentThread().getName());
        });

        Thread t2 = factory.newThread(() -> {
            System.out.println("Second worker: " + Thread.currentThread().getName());
        });

        t1.start();
        t2.start();
    }
}
```

##### Method 4: Executors.newVirtualThreadPerTaskExecutor() - Most Practical

```java
import java.util.concurrent.*;

public class ExecutorServiceExample {
    public static void main(String[] args) {
        // Creates ONE virtual thread PER task (never pool them!)
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {

            // Submit tasks - each gets its own virtual thread
            Future<String> future1 = executor.submit(() -> {
                Thread.sleep(1000); // Blocking is fine!
                return "Result 1";
            });

            Future<String> future2 = executor.submit(() -> {
                Thread.sleep(500);
                return "Result 2";
            });

            // Get results (blocking, but cheap!)
            System.out.println(future1.get());
            System.out.println(future2.get());

        } // Auto-closed: waits for all tasks
    }
}
```

#### ExecutorService with Virtual Threads

- The ExecutorService API has been enhanced with virtual thread support
- Complete Example with All Methods

```java
import java.util.concurrent.*;
import java.util.List;
import java.util.stream.Stream;

public class VirtualThreadExecutorDemo {
    public static void main(String[] args) throws Exception {
        // Modern way: try-with-resources ensures proper cleanup
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {

            // 1. Single task with result
            Future<String> future = executor.submit(() -> {
                Thread.sleep(500);
                return "Task completed";
            });
            System.out.println("Result: " + future.get());

            // 2. Multiple tasks - get Stream of completed Futures
            Stream<Future<String>> stream = executor.submit(
                    List.of(
                            () -> {
                                Thread.sleep(300);
                                return "Fast";
                            },
                            () -> {
                                Thread.sleep(600);
                                return "Slow";
                            }
                    )
            );

            stream.filter(Future::isDone)
                    .map(Future::join)
                    .forEach(System.out::println);

            // 3. invokeAll - wait for ALL to complete
            List<Callable<String>> tasks = List.of(
                    () -> {
                        Thread.sleep(200);
                        return "A";
                    },
                    () -> {
                        Thread.sleep(400);
                        return "B";
                    },
                    () -> {
                        Thread.sleep(100);
                        return "C";
                    }
            );

            List<Future<String>> allResults = executor.invokeAll(tasks);
            for (Future<String> f : allResults) {
                System.out.println("All completed: " + f.get());
            }

            // 4. invokeAny - return first completed, cancel others
            String first = executor.invokeAny(List.of(
                    () -> {
                        Thread.sleep(500);
                        return "First but slow";
                    },
                    () -> {
                        Thread.sleep(100);
                        return "Fastest!";
                    },
                    () -> {
                        Thread.sleep(300);
                        return "Medium";
                    }
            ));
            System.out.println("Winner: " + first);
        }
    }
}
```

- Key Point: Never Pool Virtual Threads

```java
class Demo {
    static void main() {

        // ‚ùå WRONG - Don't do this!
        ExecutorService wrong = Executors.newFixedThreadPool(10);
        for (
                int i = 0;
                i < 1000; i++) {
            wrong.submit(() -> {
                // This double-schedules: platform thread pool + virtual thread
                Thread.startVirtualThread(() -> {
                    // work
                });
            });
        }

// ‚úÖ CORRECT - One virtual thread per task
        try (
                ExecutorService correct = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1000; i++) {
                correct.submit(() -> {
                    // work - runs directly on a virtual thread
                });
            }
        }
    }
}
```

### Performance Comparison: Virtual vs Platform Threads

**Test: 10,000 Tasks with I/O (Thread.sleep)**

```java
import java.lang.management.*;
import java.util.concurrent.*;
import java.util.ArrayList;
import java.util.List;

public class PerformanceComparison {

    public static void main(String[] args) throws Exception {
        System.out.println("=== Performance: Virtual Threads vs Platform Threads ===\n");

        // Test 1: Virtual Threads
        long vTime = testVirtualThreads(10_000);

        // Test 2: Platform Threads (with different pool sizes)
        long pTime200 = testPlatformThreads(10_000, 200);
        long pTime500 = testPlatformThreads(10_000, 500);
        long pTime1000 = testPlatformThreads(10_000, 1000);

        System.out.println("\nüìä Results (10,000 tasks, each sleeping 500ms):");
        System.out.printf("  Virtual Threads:         %d ms\n", vTime);
        System.out.printf("  Platform Threads (200):   %d ms\n", pTime200);
        System.out.printf("  Platform Threads (500):   %d ms\n", pTime500);
        System.out.printf("  Platform Threads (1000):  %d ms\n", pTime1000);
    }

    private static long testVirtualThreads(int taskCount) throws Exception {
        long start = System.currentTimeMillis();

        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            List<Future<?>> futures = new ArrayList<>();
            for (int i = 0; i < taskCount; i++) {
                futures.add(executor.submit(() -> {
                    try {
                        Thread.sleep(500);
                    } catch (Exception e) {
                    }
                }));
            }
            // Wait for all
            for (Future<?> f : futures) f.get();
        }

        return System.currentTimeMillis() - start;
    }

    private static long testPlatformThreads(int taskCount, int poolSize) throws Exception {
        long start = System.currentTimeMillis();

        try (ExecutorService executor = Executors.newFixedThreadPool(poolSize)) {
            List<Future<?>> futures = new ArrayList<>();
            for (int i = 0; i < taskCount; i++) {
                futures.add(executor.submit(() -> {
                    try {
                        Thread.sleep(500);
                    } catch (Exception e) {
                    }
                }));
            }
            for (Future<?> f : futures) f.get();
        }

        return System.currentTimeMillis() - start;
    }
}
```

output:

```text
üìä Results (10,000 tasks, each sleeping 500ms):
  Virtual Threads:         1,316 ms
  Platform Threads (200):   25,619 ms
  Platform Threads (500):   10,277 ms
  Platform Threads (1000):   5,197 ms
```

#### Key Observations

- Virtual threads use only ~22 platform threads to handle 10,000 concurrent tasks
- To match virtual thread performance, platform threads need pool size ‚âà task count
- Virtual threads are 5-20x faster for I/O-heavy workloads

==================================================================================

### Important Differences and Limitations

#### Thread API Differences

```java
public class ThreadDifferences {
    public static void main(String[] args) {
        Thread vt = Thread.ofVirtual().start(() -> {
            Thread current = Thread.currentThread();

            // 1. Check if virtual
            System.out.println("Is virtual? " + current.isVirtual()); // true

            // 2. Priority - always NORM_PRIORITY (5)
            System.out.println("Priority: " + current.getPriority()); // 5
            current.setPriority(Thread.MAX_PRIORITY); // ‚ùå Has no effect!

            // 3. Daemon - always true
            System.out.println("Is daemon? " + current.isDaemon()); // true

            // 4. Thread group - all virtual threads in same group
            System.out.println("Thread group: " + current.getThreadGroup());

            // 5. Can't suspend/resume/stop (deprecated anyway)
            // current.suspend(); // ‚ùå UnsupportedOperationException
        });

        // 6. getAllStackTraces - doesn't include virtual threads
        System.out.println("Platform threads only: " +
                Thread.getAllStackTraces().size());

        // 7. New methods
        System.out.println("Thread ID (final): " + vt.threadId());
    }
}
```

| Feature                       | Virtual Thread Behavior                                    |
|-------------------------------|------------------------------------------------------------|
| Priority                      | Always NORM_PRIORITY (5), cannot be changed                |
| Daemon Status                 | Always daemon threads, cannot be changed                   |
| Thread Group                  | All virtual threads belong to the same system thread group |
| suspend() / resume() / stop() | Unsupported (throws UnsupportedOperationException)         |
| getAllStackTraces()           | Does NOT include virtual threads                           |
| Debugging                     | JDWP requires opt-in for virtual thread events             |



### Pinning: The Critical Gotcha
- Pinning occurs when a virtual thread cannot be unmounted from its carrier thread, blocking the carrier from executing other virtual threads.

**What Causes Pinning?**

```java
public class PinningExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) {
        // SCENARIO 1: synchronized block inside virtual thread - CAN PIN!
        Thread.ofVirtual().start(() -> {
            synchronized(lock) { // ‚ö†Ô∏è May pin carrier thread
                try {
                    Thread.sleep(1000); // Blocking inside synchronized
                } catch (Exception e) {}
            }
        });
        
        // SCENARIO 2: Object.wait() - ALWAYS pins!
        Thread.ofVirtual().start(() -> {
            synchronized(lock) {
                try {
                    lock.wait(); // ‚ö†Ô∏è Definitely pins while waiting
                } catch (Exception e) {}
            }
        });
        
        // SCENARIO 3: Native method calls - MAY PIN
        Thread.ofVirtual().start(() -> {
            // Some native method calls might pin
        });
    }
}
```

**How to Detect Pinning**
```text
# Run with this flag to trace pinned threads
java -Djdk.tracePinnedThreads=full YourApplication
```
Output shows where pinning occurs:
```text
Thread[#23,ForkJoinPool-1-worker-1,5,CarrierThreads]
    java.base/java.lang.VirtualThread$VThreadContinuation.onPinned(VirtualThread.java:183)
    com.example.PinningExample.lambda$main$0(PinningExample.java:10) <== blocks at synchronized
```
#### Solution: Use ReentrantLock Instead of synchronized

```java
import java.util.concurrent.locks.ReentrantLock;

public class AvoidPinning {
    private final ReentrantLock lock = new ReentrantLock();
    
    public void safeMethod() {
        lock.lock(); // ‚úÖ Does NOT pin virtual threads
        try {
            Thread.sleep(1000); // Blocking is fine - virtual thread unmounts
        } catch (Exception e) {
        } finally {
            lock.unlock();
        }
    }
    
    public static void main(String[] args) {
        AvoidPinning example = new AvoidPinning();
        
        // These virtual threads won't pin carrier threads
        Thread.ofVirtual().start(example::safeMethod);
        Thread.ofVirtual().start(example::safeMethod);
        Thread.ofVirtual().start(example::safeMethod);
    }
}
```
- Java 24 includes improvements to reduce pinning in synchronized blocks 

### ThreadLocals and Virtual Threads

**The Problem with ThreadLocal**

```java
public class ThreadLocalProblem {
    private static final ThreadLocal<String> context = new ThreadLocal<>();
    
    public static void main(String[] args) {
        // ‚ùå Anti-pattern: ThreadLocal with virtual threads
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 1_000_000; i++) {
                int id = i;
                executor.submit(() -> {
                    // Each virtual thread gets NEW ThreadLocal instance!
                    context.set("Request-" + id);
                    
                    // Expensive object created per thread - NO REUSE!
                    ExpensiveObject obj = context.get(); 
                    
                    process(obj);
                    
                    // MUST clean up or memory leak!
                    context.remove(); 
                });
            }
        }
    }
}
```
**Problems with ThreadLocal in Virtual Threads**
- No thread reuse - Each virtual thread is new, so ThreadLocal creates new instances for every task
- Memory leaks - Must explicitly remove() or risk heap exhaustion
- Caching fails - Cannot cache expensive objects across tasks

**Solutions**

#####  Use Scoped Values (Java 21+)

```java
// ScopedValue - immutable, sharable, no cleanup needed
public class ScopedValueExample {
    // Define a ScopedValue (like ThreadLocal but immutable)
    private static final ScopedValue<String> REQUEST_ID = ScopedValue.newInstance();
    
    public static void main(String[] args) {
        // Bind value for a scope
        ScopedValue.where(REQUEST_ID, "req-123")
                   .run(() -> {
                       // Inside this scope, REQUEST_ID is available
                       handleRequest();
                   });
        // After scope exits, value is automatically gone
    }
    
    private static void handleRequest() {
        String requestId = REQUEST_ID.get(); // Get the bound value
        System.out.println("Processing: " + requestId);
        
        // All nested calls can access it
        processRequest();
    }
    
    private static void processRequest() {
        // Still accessible!
        System.out.println("Nested access: " + REQUEST_ID.get());
    }
}
```

##### Use Limited Pool for Caching

```java
public class CachingWithVirtualThreads {
    // For caching expensive objects, use a FIXED pool, not virtual threads
    private static final ExecutorService CACHE_POOL = 
        Executors.newFixedThreadPool(4); // Small pool for caching
    
    private static final ThreadLocal<ExpensiveObject> CACHE = 
        ThreadLocal.withInitial(ExpensiveObject::new);
    
    public static void main(String[] args) {
        try (var vtPool = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // I/O-bound work uses virtual threads
            vtPool.submit(() -> doIOWork());
            
            // CPU/caching work uses fixed pool with ThreadLocal reuse
            CACHE_POOL.submit(() -> {
                ExpensiveObject obj = CACHE.get(); // Reused!
                obj.process();
            });
        }
    }
}
```

### Rate Limiting and Resource Protection
- virtual threads enable massive concurrency, you must protect downstream services

**Using Semaphore for Rate Limiting**

```java
import java.util.concurrent.*;

public class RateLimitingExample {
    // Allow only 20 concurrent requests to external API
    private static final Semaphore API_SEMAPHORE = new Semaphore(20);
    private static final HttpClient client = HttpClient.newHttpClient();
    
    public static void main(String[] args) {
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // Even with 1000 tasks, only 20 hit API simultaneously
            for (int i = 0; i < 1000; i++) {
                int id = i;
                executor.submit(() -> {
                    String result = callExternalApi("https://api.example.com/data");
                    System.out.println("Task " + id + ": " + result);
                });
            }
        }
    }
    
    private static String callExternalApi(String url) {
        try {
            // Acquire permit - blocks if >20 concurrent
            API_SEMAPHORE.acquire(); // Blocking is cheap with virtual threads!
            
            try {
                // Actually call API
                HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .build();
                    
                HttpResponse<String> response = client.send(
                    request, 
                    HttpResponse.BodyHandlers.ofString()
                );
                
                return response.body();
                
            } finally {
                API_SEMAPHORE.release(); // Always release
            }
            
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }
}
```
**Alternative: Bulkhead Pattern**

```java
public class BulkheadPattern {
    // Separate semaphores for different services
    private static final Semaphore DB_SEMAPHORE = new Semaphore(30);
    private static final Semaphore REDIS_SEMAPHORE = new Semaphore(50);
    private static final Semaphore API_SEMAPHORE = new Semaphore(10);
    
    public void processRequest() {
        // Each resource protected independently
        CompletableFuture.supplyAsync(this::queryDatabase)
            .thenCompose(dbResult -> 
                CompletableFuture.supplyAsync(() -> callRedis(dbResult)))
            .thenCompose(redisResult ->
                CompletableFuture.supplyAsync(() -> callExternalApi(redisResult)))
            .join();
    }
    
    private String queryDatabase() {
        try {
            DB_SEMAPHORE.acquire();
            // Database query
            return "db-result";
        } catch (Exception e) {
            return "error";
        } finally {
            DB_SEMAPHORE.release();
        }
    }
    
    private String callRedis(String input) {
        try {
            REDIS_SEMAPHORE.acquire();
            // Redis operation
            return "redis-" + input;
        } catch (Exception e) {
            return "error";
        } finally {
            REDIS_SEMAPHORE.release();
        }
    }
    
    private String callExternalApi(String input) {
        try {
            API_SEMAPHORE.acquire();
            // External API call
            return "api-" + input;
        } catch (Exception e) {
            return "error";
        } finally {
            API_SEMAPHORE.release();
        }
    }
}
```

### Monitoring and Debugging Virtual Threads

**JVM Flags for Debugging**

```text
# Trace pinned threads (identify blocking issues)
java -Djdk.tracePinnedThreads=short YourApp

# Full stack traces for pinned threads
java -Djdk.tracePinnedThreads=full YourApp

# Configure carrier thread pool parallelism (default = CPU cores)
java -Djdk.virtualThreadScheduler.parallelism=16 YourApp
```

**Using Java Flight Recorder (JFR)**

```java
import jdk.jfr.consumer.*;
import java.nio.file.Path;

public class MonitorVirtualThreads {
    public static void main(String[] args) throws Exception {
        // Enable JFR with virtual thread events
        // Run with: -XX:StartFlightRecording:filename=recording.jfr
        
        // Later, analyze recording
        Path recordingPath = Path.of("recording.jfr");
        try (RecordingFile recording = new RecordingFile(recordingPath)) {
            while (recording.hasMoreEvents()) {
                RecordedEvent event = recording.readEvent();
                
                if (event.getEventType().getName()
                    .contains("VirtualThread")) {
                    System.out.println(event);
                }
            }
        }
    }
}
```
**Programmatic Monitoring**

```java
import java.lang.management.*;
import java.util.concurrent.*;

public class ThreadMonitoring {
    
    public static void printThreadStats() {
        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
        
        // Platform threads only!
        int platformCount = threadBean.getThreadCount();
        
        // Estimate virtual threads (indirectly)
        long totalCreated = threadBean.getTotalStartedThreadCount();
        
        System.out.println("Platform threads: " + platformCount);
        System.out.println("Total threads created: " + totalCreated);
        System.out.println("Virtual threads estimate: " + 
                          (totalCreated - platformCount));
        
        // Get stack traces of platform threads only
        ThreadInfo[] threadInfos = threadBean.dumpAllThreads(false, false);
        System.out.println("\nPlatform threads with stacks:");
        for (ThreadInfo info : threadInfos) {
            System.out.println("  " + info.getThreadName());
        }
    }
    
    public static void main(String[] args) {
        // Start some virtual threads
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            for (int i = 0; i < 100; i++) {
                executor.submit(() -> {
                    try { Thread.sleep(1000); } catch (Exception e) {}
                });
            }
            
            // Check stats while threads are running
            printThreadStats();
        }
    }
}
```
===============================
### Real-World Example: High-Performance Microservice

```java
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.*;
import java.util.*;
import java.time.*;
import java.time.format.DateTimeFormatter;

@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    private final RestTemplate restTemplate = new RestTemplate();
    private final ExecutorService virtualExecutor = 
        Executors.newVirtualThreadPerTaskExecutor();
    
    // External service endpoints
    private static final String INVENTORY_SERVICE = 
        "https://inventory-service.example.com";
    private static final String PAYMENT_SERVICE = 
        "https://payment-service.example.com";
    private static final String SHIPPING_SERVICE = 
        "https://shipping-service.example.com";
    
    // Rate limiters
    private final Semaphore inventorySemaphore = new Semaphore(20);
    private final Semaphore paymentSemaphore = new Semaphore(15);
    private final Semaphore shippingSemaphore = new Semaphore(10);
    
    @PostMapping("/process-batch")
    public ResponseEntity<BatchResult> processBatch(
            @RequestBody List<OrderRequest> orders) {
        
        long startTime = System.currentTimeMillis();
        List<CompletableFuture<OrderResult>> futures = new ArrayList<>();
        
        // Each order gets its own virtual thread
        for (OrderRequest order : orders) {
            CompletableFuture<OrderResult> future = 
                CompletableFuture.supplyAsync(
                    () -> processSingleOrder(order),
                    virtualExecutor
                );
            futures.add(future);
        }
        
        // Wait for all to complete
        List<OrderResult> results = futures.stream()
            .map(CompletableFuture::join)
            .toList();
        
        long duration = System.currentTimeMillis() - startTime;
        
        BatchResult batchResult = new BatchResult(
            results,
            duration,
            results.stream().filter(r -> r.success()).count(),
            results.stream().filter(r -> !r.success()).count()
        );
        
        return ResponseEntity.ok(batchResult);
    }
    
    private OrderResult processSingleOrder(OrderRequest order) {
        String orderId = UUID.randomUUID().toString();
        Map<String, Object> details = new HashMap<>();
        List<String> steps = new ArrayList<>();
        
        try {
            // Step 1: Validate order (quick DB op)
            steps.add(validateOrder(order));
            
            // Step 2: Check inventory (external API with rate limiting)
            steps.add(checkInventory(order, details));
            
            // Step 3: Process payment (external API with rate limiting)
            steps.add(processPayment(order, details));
            
            // Step 4: Update database
            steps.add(updateDatabase(order, orderId, details));
            
            // Step 5: Schedule shipping (external API)
            steps.add(scheduleShipping(order, details));
            
            // Step 6: Send notifications
            steps.add(sendNotifications(order));
            
            return new OrderResult(orderId, true, steps, null);
            
        } catch (Exception e) {
            return new OrderResult(orderId, false, steps, e.getMessage());
        }
    }
    
    private String validateOrder(OrderRequest order) {
        // Quick database lookup
        Integer count = jdbcTemplate.queryForObject(
            "SELECT COUNT(*) FROM products WHERE id = ?",
            Integer.class,
            order.productId()
        );
        
        if (count == null || count == 0) {
            throw new RuntimeException("Product not found");
        }
        
        return "Validation OK";
    }
    
    private String checkInventory(OrderRequest order, Map<String, Object> details) 
            throws InterruptedException {
        
        inventorySemaphore.acquire();
        try {
            // Simulate inventory API call
            String url = INVENTORY_SERVICE + "/check?product=" + 
                        order.productId() + "&quantity=" + order.quantity();
            
            InventoryResponse response = restTemplate.getForObject(
                url, 
                InventoryResponse.class
            );
            
            if (!response.available()) {
                throw new RuntimeException("Insufficient inventory");
            }
            
            details.put("inventory", response);
            return "Inventory OK";
            
        } finally {
            inventorySemaphore.release();
        }
    }
    
    private String processPayment(OrderRequest order, Map<String, Object> details) 
            throws InterruptedException {
        
        paymentSemaphore.acquire();
        try {
            // Process payment
            PaymentRequest paymentReq = new PaymentRequest(
                order.customerId(),
                order.amount(),
                order.paymentMethod()
            );
            
            PaymentResponse response = restTemplate.postForObject(
                PAYMENT_SERVICE + "/process",
                paymentReq,
                PaymentResponse.class
            );
            
            if (!response.success()) {
                throw new RuntimeException("Payment failed: " + response.message());
            }
            
            details.put("payment", response);
            return "Payment OK";
            
        } finally {
            paymentSemaphore.release();
        }
    }
    
    private String updateDatabase(OrderRequest order, String orderId, 
                                  Map<String, Object> details) {
        
        jdbcTemplate.update(
            "INSERT INTO orders (id, customer_id, product_id, quantity, " +
            "amount, status, details, created_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
            orderId,
            order.customerId(),
            order.productId(),
            order.quantity(),
            order.amount(),
            "PROCESSED",
            details.toString(),
            LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME)
        );
        
        return "Database updated";
    }
    
    private String scheduleShipping(OrderRequest order, Map<String, Object> details) 
            throws InterruptedException {
        
        shippingSemaphore.acquire();
        try {
            ShippingRequest shippingReq = new ShippingRequest(
                order.customerId(),
                order.address(),
                (String) details.get("inventory") // inventory details
            );
            
            ShippingResponse response = restTemplate.postForObject(
                SHIPPING_SERVICE + "/schedule",
                shippingReq,
                ShippingResponse.class
            );
            
            details.put("shipping", response);
            return "Shipping scheduled";
            
        } finally {
            shippingSemaphore.release();
        }
    }
    
    private String sendNotifications(OrderRequest order) {
        // Fire and forget - don't wait
        CompletableFuture.runAsync(() -> {
            try {
                // Send email, SMS, etc.
                Thread.sleep(200); // Simulate notification delay
            } catch (Exception e) {}
        }, virtualExecutor);
        
        return "Notifications queued";
    }
    
    // Record types for responses
    record OrderRequest(String productId, int quantity, String customerId,
                        double amount, String paymentMethod, String address) {}
    
    record OrderResult(String orderId, boolean success, List<String> steps, 
                       String error) {}
    
    record BatchResult(List<OrderResult> results, long processingTimeMs,
                       long successCount, long failureCount) {}
    
    record InventoryResponse(boolean available, int stockLevel) {}
    record PaymentResponse(boolean success, String message, String transactionId) {}
    record ShippingRequest(String customerId, String address, Object details) {}
    record ShippingResponse(String trackingNumber, String estimatedDelivery) {}
}
```
**Springboot Configuration**
```properties
# application.properties
spring.threads.virtual.enabled=true

# Connection pool for database (still needed!)
spring.datasource.hikari.maximum-pool-size=20

# Server configuration
server.tomcat.threads.max=200  # Platform threads for accepting connections
# Once accepted, requests run on virtual threads
```

### Quick Reference Card

```java
import java.time.Duration;
import java.util.List;
import java.util.concurrent.*;

class Demo {

    public static void main(String[] args) throws Exception {

        Runnable task = () -> System.out.println("Running task...");
        Callable<String> callable = () -> "Task result";

        // CREATE VIRTUAL THREADS
        Thread vt1 = Thread.startVirtualThread(task);                          // Simplest
        Thread vt2 = Thread.ofVirtual().name("my-thread").start(task);         // Builder
        ThreadFactory factory = Thread.ofVirtual().factory();                  // Factory
        ExecutorService exec = Executors.newVirtualThreadPerTaskExecutor();    // Best for most

        // CHECK IF VIRTUAL
        boolean isVirtual = Thread.currentThread().isVirtual();

        // WAIT FOR COMPLETION
        vt1.join();                                      // Wait indefinitely
        vt2.join(Duration.ofSeconds(5));                 // Wait with timeout

        // HANDLE RESULTS
        Future<String> future = exec.submit(callable);
        String result = future.get();                    // Blocking is cheap!

        // MULTIPLE TASKS
        List<Callable<String>> tasks = List.of(callable, callable);
        List<Future<String>> futures = exec.invokeAll(tasks);  // Wait for all
        String first = exec.invokeAny(tasks);                  // Get fastest

        // RATE LIMITING
        Semaphore semaphore = new Semaphore(20);
        semaphore.acquire();  // Blocks virtual thread (cheap!)
        try {
            // use resource
        } finally {
            semaphore.release();
        }

        // AVOID PINNING
        ReentrantLock lock = new ReentrantLock();
        lock.lock();  // Use ReentrantLock, not synchronized
        try {
            // blocking I/O
        } finally {
            lock.unlock();
        }

        // DEBUG PINNING
        // Run with: java -Djdk.tracePinnedThreads=full YourApp

        // MONITOR HEAP (for virtual thread stacks)
        // Example JVM option: -XX:MaxHeapSize=4g
    }
}

```