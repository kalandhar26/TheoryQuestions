### CyclicBarrier

- A reusable barrier that allows threads to wait for each other to reach a common point
- A meeting point where hikers wait for everyone to arrive before continuing (reusable at each checkpoint)

#### How It Works

```text
Initial State (parties=3):
Threads: [T1, T2, T3] all doing work
           ‚Üì
T1 reaches barrier ‚Üí waits
T2 reaches barrier ‚Üí waits
T3 reaches barrier ‚Üí ALL RELEASED + barrier resets!
           ‚Üì
Threads continue to next phase
           ‚Üì
Can repeat the cycle again!
```

| Method                                              | Description            | Behavior                                                         |
|-----------------------------------------------------|------------------------|------------------------------------------------------------------|
| CyclicBarrier(int parties)                          | Constructor            | Creates barrier for N threads                                   |
| CyclicBarrier(int parties, Runnable action)         | Constructor            | Runs action when barrier is tripped                             |
| await()                                             | Waits at barrier       | Returns arrival index (0 to parties - 1)                        |
| await(long timeout, TimeUnit)                       | Waits with timeout     | Throws TimeoutException if timeout occurs                       |
| reset()                                             | Resets barrier         | Use carefully ‚Äì may cause BrokenBarrierException                |
| getNumberWaiting()                                  | Current waiters        | Diagnostic purpose                                              |
| getParties()                                        | Total parties          | Returns configured number of threads                            |
| isBroken()                                          | Check if broken        | True after timeout, interruption, or reset failure              |


#### Multi-Phase Computation

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ThreadLocalRandom;

class Worker implements Runnable {
    private final int workerId;
    private final CyclicBarrier barrier;
    private final int[] phaseResults;
    
    public Worker(int workerId, CyclicBarrier barrier, int[] phaseResults) {
        this.workerId = workerId;
        this.barrier = barrier;
        this.phaseResults = phaseResults;
    }
    
    @Override
    public void run() {
        try {
            // Phase 1: Data loading
            System.out.println("Worker " + workerId + " started PHASE 1: Loading data");
            Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 3000));
            phaseResults[workerId] = workerId * 10; // Some computed value
            System.out.println("Worker " + workerId + " completed PHASE 1");
            
            // Wait for all workers to complete phase 1
            barrier.await();
            
            // Phase 2: Data processing (using results from phase 1)
            System.out.println("Worker " + workerId + " started PHASE 2: Processing with " + 
                             phaseResults[workerId]);
            Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 2000));
            phaseResults[workerId] = phaseResults[workerId] * 2;
            System.out.println("Worker " + workerId + " completed PHASE 2");
            
            // Wait for all workers to complete phase 2
            barrier.await();
            
            // Phase 3: Final aggregation
            System.out.println("Worker " + workerId + " started PHASE 3: Final result = " + 
                             phaseResults[workerId]);
            
        } catch (InterruptedException | BrokenBarrierException e) {
            Thread.currentThread().interrupt();
            System.out.println("Worker " + workerId + " interrupted: " + e.getMessage());
        }
    }
}

public class MultiPhaseComputation {
    public static void main(String[] args) {
        int numberOfWorkers = 3;
        int[] phaseResults = new int[numberOfWorkers];
        
        System.out.println("=== Multi-Phase Computation with CyclicBarrier ===\n");
        
        // Create barrier with barrier action (runs when all threads reach barrier)
        CyclicBarrier barrier = new CyclicBarrier(
            numberOfWorkers,
            () -> {
                System.out.println("\nüéØ BARRIER TRIPPED! All workers reached this phase.");
                System.out.println("Current results: " + java.util.Arrays.toString(phaseResults));
                System.out.println("Moving to next phase...\n");
            }
        );
        
        // Create and start workers
        for (int i = 0; i < numberOfWorkers; i++) {
            new Thread(new Worker(i, barrier, phaseResults), "Worker-" + i).start();
        }
    }
}
```
output

```text
=== Multi-Phase Computation with CyclicBarrier ===

Worker 0 started PHASE 1: Loading data
Worker 1 started PHASE 1: Loading data
Worker 2 started PHASE 1: Loading data
Worker 2 completed PHASE 1
Worker 1 completed PHASE 1
Worker 0 completed PHASE 1

üéØ BARRIER TRIPPED! All workers reached this phase.
Current results: [10, 20, 0]
Moving to next phase...

Worker 2 started PHASE 2: Processing with 0
Worker 0 started PHASE 2: Processing with 10
Worker 1 started PHASE 2: Processing with 20
Worker 2 completed PHASE 2
Worker 0 completed PHASE 2
Worker 1 completed PHASE 2

üéØ BARRIER TRIPPED! All workers reached this phase.
Current results: [20, 40, 0]
Moving to next phase...

Worker 2 started PHASE 3: Final result = 0
Worker 0 started PHASE 3: Final result = 20
Worker 1 started PHASE 3: Final result = 40
```

#### Matrix Multiplication with CyclicBarrier

```java
class MatrixWorker implements Runnable {
    private final int[][] matrixA;
    private final int[][] matrixB;
    private final int[][] result;
    private final int row;
    private final CyclicBarrier barrier;
    
    public MatrixWorker(int[][] matrixA, int[][] matrixB, int[][] result, 
                       int row, CyclicBarrier barrier) {
        this.matrixA = matrixA;
        this.matrixB = matrixB;
        this.result = result;
        this.row = row;
        this.barrier = barrier;
    }
    
    @Override
    public void run() {
        try {
            // Compute one row of result
            for (int col = 0; col < matrixB[0].length; col++) {
                int sum = 0;
                for (int k = 0; k < matrixA[0].length; k++) {
                    sum += matrixA[row][k] * matrixB[k][col];
                }
                result[row][col] = sum;
            }
            
            System.out.println("‚úÖ Row " + row + " computed by " + 
                             Thread.currentThread().getName());
            
            // Wait for all rows to be computed
            barrier.await();
            
            // After barrier, verify results (if needed)
            if (row == 0) {
                System.out.println("\nüéØ All rows computed! Matrix multiplication complete!");
                printMatrix(result);
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void printMatrix(int[][] matrix) {
        System.out.println("\nResult Matrix:");
        for (int[] row : matrix) {
            System.out.println(java.util.Arrays.toString(row));
        }
    }
}

public class MatrixMultiplication {
    public static void main(String[] args) {
        int size = 3;
        int[][] matrixA = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        int[][] matrixB = {
            {9, 8, 7},
            {6, 5, 4},
            {3, 2, 1}
        };
        
        int[][] result = new int[size][size];
        
        System.out.println("=== Parallel Matrix Multiplication ===\n");
        System.out.println("Matrix A:");
        printMatrix(matrixA);
        System.out.println("\nMatrix B:");
        printMatrix(matrixB);
        System.out.println();
        
        // Create barrier for all rows
        CyclicBarrier barrier = new CyclicBarrier(size);
        
        // Create one thread per row
        for (int row = 0; row < size; row++) {
            MatrixWorker worker = new MatrixWorker(
                matrixA, matrixB, result, row, barrier
            );
            new Thread(worker, "Worker-Row" + row).start();
        }
    }
    
    private static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            System.out.println(java.util.Arrays.toString(row));
        }
    }
}
```

##### Simulated Racing Game with Checkpoints

```java
import java.util.concurrent.*;
import java.util.*;

class RaceCar implements Runnable {
    private final String carName;
    private final CyclicBarrier checkpoint;
    private final int totalLaps;
    private int position = 0;
    private final Random random = new Random();
    
    public RaceCar(String carName, CyclicBarrier checkpoint, int totalLaps) {
        this.carName = carName;
        this.checkpoint = checkpoint;
        this.totalLaps = totalLaps;
    }
    
    @Override
    public void run() {
        try {
            System.out.println(carName + " is on the starting grid üèéÔ∏è");
            
            for (int lap = 1; lap <= totalLaps; lap++) {
                // Drive the lap
                System.out.println(carName + " starting Lap " + lap);
                Thread.sleep(random.nextInt(1000, 3000)); // Drive lap
                position += random.nextInt(10, 50); // Random progress
                
                System.out.println(carName + " completed Lap " + lap + 
                                 " (position: " + position + ")");
                
                // Wait at checkpoint for all cars
                int arrived = checkpoint.await();
                
                if (arrived == 0) {
                    // First car to checkpoint
                    System.out.println("\nüèÅ All cars completed Lap " + lap + "! üèÅ\n");
                }
            }
            
            // Race finished
            System.out.println("üéâ " + carName + " FINISHED! Final position: " + position);
            
        } catch (Exception e) {
            System.out.println(carName + " crashed: " + e.getMessage());
        }
    }
}

public class RacingGame {
    public static void main(String[] args) {
        int numberOfCars = 4;
        int totalLaps = 3;
        
        System.out.println("=== FORMULA 1 RACE STARTING ===\n");
        
        // Create checkpoint barrier with action
        CyclicBarrier checkpoint = new CyclicBarrier(
            numberOfCars,
            () -> System.out.println("‚è±Ô∏è  CHECKPOINT: All cars have passed this point!\n")
        );
        
        // Create and start race cars
        List<RaceCar> cars = Arrays.asList(
            new RaceCar("Ferrari", checkpoint, totalLaps),
            new RaceCar("Mercedes", checkpoint, totalLaps),
            new RaceCar("Red Bull", checkpoint, totalLaps),
            new RaceCar("McLaren", checkpoint, totalLaps)
        );
        
        ExecutorService raceTrack = Executors.newFixedThreadPool(numberOfCars);
        
        for (RaceCar car : cars) {
            raceTrack.submit(car);
        }
        
        raceTrack.shutdown();
        try {
            raceTrack.awaitTermination(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {}
        
        System.out.println("\nüèÜ RACE COMPLETED! üèÜ");
    }
}
```

### Common Pitfalls

```java
public class BarrierPitfalls {

    // ‚ùå WRONG: Not handling BrokenBarrierException
    public void badBarrier() {
        CyclicBarrier barrier = new CyclicBarrier(3);

        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    barrier.await(); // Might throw BrokenBarrierException
                } catch (InterruptedException e) {
                    // Handled
                }
                // BrokenBarrierException not caught! üíÄ
            }).start();
        }
    }

    // ‚úÖ CORRECT: Handle both exceptions
    public void goodBarrier() {
        CyclicBarrier barrier = new CyclicBarrier(3);

        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } catch (BrokenBarrierException e) {
                    System.out.println("Barrier broken: " + e.getMessage());
                    // Check if barrier is usable
                    if (barrier.isBroken()) {
                        barrier.reset(); // Reset for next use
                    }
                }
            }).start();
        }
    }

    // ‚ùå WRONG: Different number of threads await()
    public void mismatchedParties() throws Exception {
        CyclicBarrier barrier = new CyclicBarrier(3);

        // Only 2 threads await
        new Thread(() -> {
            try { barrier.await(); } catch (Exception e) {}
        }).start();

        new Thread(() -> {
            try { barrier.await(); } catch (Exception e) {}
        }).start();

        // Third thread never arrives - barrier never trips!
        // barrier.await(1, TimeUnit.SECONDS); // Would timeout
    }
}
```

===================


### Real-World Example: Batch Processing System

```java
import java.util.concurrent.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

class BatchProcessor {
    private final int batchSize;
    private final CyclicBarrier processingBarrier;
    private final CountDownLatch completionLatch;
    private final List<Record> batch;
    private final AtomicInteger processedCount = new AtomicInteger(0);
    private final AtomicInteger errorCount = new AtomicInteger(0);
    
    public BatchProcessor(int batchSize, int numberOfThreads) {
        this.batchSize = batchSize;
        this.batch = new CopyOnWriteArrayList<>();
        
        // Barrier for coordinating processing phases
        this.processingBarrier = new CyclicBarrier(
            numberOfThreads,
            this::processBatch // Barrier action runs when all threads reach barrier
        );
        
        // Latch for completion tracking
        this.completionLatch = new CountDownLatch(numberOfThreads);
    }
    
    private void processBatch() {
        System.out.println("\nüìä PROCESSING BATCH of " + batch.size() + " records");
        
        // Simulate batch processing
        for (Record record : batch) {
            try {
                // Process record
                Thread.sleep(10);
                processedCount.incrementAndGet();
            } catch (Exception e) {
                errorCount.incrementAndGet();
            }
        }
        
        // Clear batch for next cycle
        batch.clear();
        System.out.println("‚úÖ Batch processed. Total: " + processedCount.get() + 
                         ", Errors: " + errorCount.get() + "\n");
    }
    
    public void start() {
        int numberOfThreads = 3;
        
        for (int i = 0; i < numberOfThreads; i++) {
            int threadId = i;
            new Thread(() -> {
                try {
                    Random random = new Random();
                    
                    for (int cycle = 0; cycle < 5; cycle++) {
                        // Each thread produces records
                        int recordsToAdd = random.nextInt(3, 8);
                        for (int j = 0; j < recordsToAdd; j++) {
                            Record record = new Record(
                                threadId * 100 + j,
                                "Data-" + threadId + "-" + j
                            );
                            batch.add(record);
                            System.out.println("üìù Thread " + threadId + 
                                             " added record: " + record.id());
                        }
                        
                        // Wait at barrier for all threads
                        System.out.println("‚è≥ Thread " + threadId + 
                                         " waiting at barrier...");
                        processingBarrier.await();
                        
                        // Simulate some work after barrier
                        Thread.sleep(random.nextInt(100, 500));
                    }
                    
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    completionLatch.countDown();
                }
            }, "Worker-" + i).start();
        }
    }
    
    public void waitForCompletion() throws InterruptedException {
        completionLatch.await();
        System.out.println("\nüéØ ALL BATCHES COMPLETED!");
        System.out.println("Total processed: " + processedCount.get());
        System.out.println("Total errors: " + errorCount.get());
    }
    
    record Record(int id, String data) {}
}

public class BatchProcessingSystem {
    public static void main(String[] args) {
        System.out.println("=== BATCH PROCESSING SYSTEM ===\n");
        
        BatchProcessor processor = new BatchProcessor(10, 3);
        processor.start();
        
        try {
            processor.waitForCompletion();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```


#### Performance Comparison

```java
public class PerformanceTest {
    private static final int THREAD_COUNT = 100;
    private static final int ITERATIONS = 1000;
    
    public static void main(String[] args) throws Exception {
        System.out.println("=== Performance Comparison ===\n");
        
        // Test CountDownLatch
        long latchTime = testCountDownLatch();
        
        // Test CyclicBarrier
        long barrierTime = testCyclicBarrier();
        
        System.out.println("\nüìä Results:");
        System.out.printf("CountDownLatch: %d ms%n", latchTime);
        System.out.printf("CyclicBarrier:  %d ms%n", barrierTime);
    }
    
    private static long testCountDownLatch() throws Exception {
        long start = System.currentTimeMillis();
        
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        
        for (int iter = 0; iter < ITERATIONS; iter++) {
            CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
            
            for (int i = 0; i < THREAD_COUNT; i++) {
                executor.submit(() -> {
                    // Simulate work
                    try { Thread.sleep(1); } catch (Exception e) {}
                    latch.countDown();
                });
            }
            
            latch.await(); // Wait for all
        }
        
        executor.shutdown();
        return System.currentTimeMillis() - start;
    }
    
    private static long testCyclicBarrier() throws Exception {
        long start = System.currentTimeMillis();
        
        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        
        for (int iter = 0; iter < ITERATIONS; iter++) {
            CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT);
            
            for (int i = 0; i < THREAD_COUNT; i++) {
                executor.submit(() -> {
                    try {
                        // Simulate work
                        Thread.sleep(1);
                        barrier.await();
                    } catch (Exception e) {}
                });
            }
        }
        
        executor.shutdown();
        return System.currentTimeMillis() - start;
    }
}
```
