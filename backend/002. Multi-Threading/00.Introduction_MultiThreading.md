#### Multi-tasking:

- Doing multiple tasks at the same time is called multitasking. Executing multiple tasks simultaneously is called
  multitasking.
- 2 Categories of multi-tasking
    1. Process based multitasking
    2. Thread based multitasking

##### Process based multitasking:

- Executing several tasking simultaneously where each task is a separate independent process. Such type of multitasking
  is called process based multitasking. While typing a java program in editor we can listen music and download files
  from same system. All these tasks will be executed simultaneously and independent of each other. Hence it is process
  based multi-tasking. It is best suitable at OS level

##### Thread based Multitasking:

- Executing several tasking simultaneously where each task is a separate independent part of the same program is called
  Thread based Multitasking. Each independent part is called Thread.
- It is the best suitable at Programmatic level.
- Whether it is processed based or thread based the main Objective of multitasking is to reduce response time of the
  system and to improve performance.
- When compared with old languages developing multithreaded applications in java is very easy because java provides
  inbuilt support multi-threading with rich API.
- Ex : Thread, Runnable, Thread Group.

##### Thread:

- Thread is separate flow of Execution. Each Thread has a separate job.

**Defining a Thread:**

- We can define a Thread in following 2 ways
    1. By extending Thread class.
    2. By Implementing Runnable Interface.
- Output is random as two threads start simultaneously. We need to use Multithreading concepts only when both jobs are
  independent.

```java
// This class extends Thread to create a new thread
class MultiThreadingDemo extends Thread {

    // The run() method contains the code that will be executed
    // when the thread is started
    @Override
    public void run() {
        // Loop to print "Child Thread" 10 times
        for (int i = 0; i < 10; i++) {
            System.out.println("Child Thread");
        }
    }
}

// Main class
public class ThreadDemo {

    public static void main(String[] args) {

        // Creating object of MultiThreadingDemo
        // This object represents a new thread
        MultiThreadingDemo t = new MultiThreadingDemo();

        // start() method creates a new thread
        // It internally calls the run() method
        t.start();

        // This loop runs in the main thread
        // It prints "Main Thread" 10 times
        for (int i = 0; i < 10; i++) {
            System.out.println("Main Thread");
        }
    }
}
```

- start() → creates a new thread and then calls run() internally.
- run() → contains the task to be executed by the child thread.
- The main() method runs in the main thread.
- Output order is not guaranteed because both threads execute concurrently.

##### Thread Scheduler:

- It is the part of JVM; it is responsible to schedule Threads. I.e. if multiple Threads are waiting to get the chance
  of execution then in which order Threads will be executed is decided by that Thread scheduler. We can expect the
  Output. It will be varied from system to system and execution to execution.

| Feature           | `t.start()`                                  | `t.run()`                                        |
|-------------------|----------------------------------------------|--------------------------------------------------|
| Thread Creation   | Creates a **new separate thread**            | Does **not create** a new thread                 |
| Execution         | JVM internally calls `run()` in a new thread | `run()` executes like a normal method call       |
| Thread Used       | Executes in **child thread**                 | Executes in **main thread**                      |
| Concurrency       | Yes – runs concurrently with main thread     | No – runs sequentially                           |
| Call Stack        | New call stack is created for new thread     | Uses existing main thread call stack             |
| Output Order      | Not predictable (depends on scheduler)       | Predictable (sequential execution)               |
| Recommended Usage | ✅ Correct way to start a thread              | ❌ Not for starting a thread (testing/debug only) |

- We will not call run() method directly, behind the scenes JVM Native method is triggered.
- The control moves from Java code -> JVM internal native code -> OS

```text
1. JVM asks the operating system 'Create a new lightweight process (thread)'
2. OS then allocates memory for a new thread stack, Assigns a Thread ID, Registers it with the scheduler, Marks it as Runnable, Now we truly have a separate thread.
3. The OS scheduler decides When this new thread will run, How long it will run, When it will be paused.
4. Java does NOT control scheduling directly — the OS does. That’s why output order is unpredictable.
5. Once the scheduler gives CPU time to that thread: The JVM internally invokes [t.run()]. It runs inside the new call stack. It runs in the child thread context
```

| Call      | What Happens Internally                                               |
|-----------|-----------------------------------------------------------------------|
| `start()` | JVM → Native → OS creates thread → Scheduler runs → JVM calls `run()` |
| `run()`   | Just a normal method call in current thread                           |

#### The Real Internal flow

- when we write 't.start()' Behind the scenes this will happen

```scss
main()
   ↓
Thread.start()
   ↓
start0()  (native method)
   ↓
JVM calls OS thread API (like pthread_create)
   ↓
New stack created
   ↓
Thread state → RUNNABLE
   ↓
Scheduler assigns CPU
   ↓
JVM invokes run() in new thread
```

#### Overriding run() method

```java
class MultiThreadingDemo1 extends Thread {

    public void run() {
        System.out.println("No Arg run method");
    }

    public void run(int i) {
        System.out.println("Int Arg run method");
    }
}
```

- The run() method can be overloaded, but start() always invokes only the no-argument run() method because the JVM
  internally calls run() with no parameters. Overloaded versions behave like normal methods and must be called
  explicitly.
- If you remove: run() and keep only run(int i). Your overloaded method is completely ignored. Will execute the empty
  run() method from Thread class, not yours.
- If We Override Start method of Thread class with our start method (), then it will be executed just like a normal
  method call. No Thread is created.

#### Override start() method

```java
class MultiThreadingDemo1 extends Thread {

    public void start() {
        System.out.println("No Arg run method");
    }
}
```

- No new thread was created.

##### Why This Breaks Multithreading

- Original Thread.start() does this internally
- But when you override start() , You completely replace that behavior, start0() is never called, No OS thread is
  created, No scheduler involvement.No concurrency
- You basically destroyed thread creation.
- If you override start() and do not call super.start(), you lose multithreading.

##### If you want to add logic before thread starts:

```java
class MultiThreadingDemo1 extends Thread {

    @Override
    public void start() {
        System.out.println("Thread is starting...");
        super.start();  // mandatory
    }

}
```

| Action                                     | Resu<br/>lt                |
|--------------------------------------------|----------------------------|
| Override `run()`                           | Correct multithreading     |
| Override `start()` without `super.start()` | No multithreading          |
| Override `start()` with `super.start()`    | Works, but not recommended |

**correct usage**

```java
public class ThreadDemo {

    public static void main(String[] args) {

        MultiThreadingDemo1 t = new MultiThreadingDemo1();

        // Calling start() method
        t.start();

        // This runs in main thread
        System.out.println("Main Thread");
    }
}

class MultiThreadingDemo1 extends Thread {

    @Override
    public void start() {

        // Calling original Thread start() method
        super.start();

        // This executes in main thread (because start() is called by main)
        System.out.println("Start method");
    }

    @Override
    public void run() {

        // This executes in child thread
        System.out.println("Run method");
    }
}
```

- super.start() → creates new thread
- Code after super.start() inside start() → runs in main thread
- run() → runs in child thread
- Output order is unpredictable because two threads are running concurrently.

#### Creating Thread with Runnable interface

- Most people think Runnable creates a thread. It doesn’t. Runnable is just a task container. Thread is the execution
  engine.

```java
public interface Runnable {
    void run();
}
```

- No thread creation. No scheduling. No lifecycle. It’s just a contract.

```scss
main()
   ↓
new Thread(r)
   ↓
t.start()
   ↓
JVM → OS creates thread
   ↓
New thread begins
   ↓
Thread.run()
   ↓
target.run()   ← your Runnable code executes
```

##### Why Runnable Is Preferred Over Extending Thread?

- If you extend Thread. You mix: Task logic, Thread mechanism. Bad design.
- If you implement Runnable. You separate: Task, Execution strategy. Cleaner architecture.
- Implementing Runnable is recommended because it promotes separation of task and execution, preserves inheritance
  flexibility, supports thread pooling, and aligns with modern concurrent programming practices.
- Runnable → defines task ;   Thread → handles execution
- This design allows same task to run in multiple threads, Works with ExecutorService, Supports thread pooling, Enables better resource management.

