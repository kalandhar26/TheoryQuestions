### Asynchronous Comuputation

- When you submit a task to a thread pool: It runs in background. You want the result later.
- You don‚Äôt want to block immediately. That‚Äôs what Future is for.
- It represents: A result that will be available in the future.

```java
import java.util.concurrent.*;

public class FutureExample {

    public static void main(String[] args) throws Exception {

        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future<String> future = executor.submit(() -> {
            Thread.sleep(2000);
            return "Task completed";
        });

        System.out.println("Doing something else...");

        String result = future.get();  // BLOCKS
        System.out.println(result);

        executor.shutdown();
    }
}
```

- submit() returns Future
- Task runs in background
- get() blocks until result is ready

#### Problem With Future

- Future is primitive.
- You can: ‚úî Check if done, ‚úî Cancel, ‚úî Block and get result.
- But you CANNOT: ‚ùå Chain tasks, ‚ùå Combine multiple futures, ‚ùå Handle errors elegantly, ‚ùå Do non-blocking callbacks
- So Future solves 30% of async problems.

### CompletableFuture

- This is where Java concurrency becomes powerful.
- CompletableFuture: Implements Future, Adds async chaining, Supports functional style, Supports composition, Supports
  error pipelines.

```java
import java.util.concurrent.*;

public class CFExample {

    public static void main(String[] args) {

        CompletableFuture<String> future =
                CompletableFuture.supplyAsync(() -> {
                    sleep(2000);
                    return "Hello";
                });

        future.thenAccept(result ->
                System.out.println("Result: " + result)
        );

        sleep(3000);
    }

    static void sleep(int ms) {
        try {
            Thread.sleep(ms);
        } catch (Exception e) {
        }
    }
}
```

- No blocking get() here.
- This is async pipeline.

#### Chaining (Where Power Begins)

```java
class CompletableFutureDemo {
    static void main() {

        CompletableFuture.supplyAsync(() -> "Hello")
                .thenApply(str -> str + " World")
                .thenApply(str -> str.toUpperCase())
                .thenAccept(System.out::println);
    }
}
```

- output

```text
HELLO WORLD
```

- This is functional async flow.

#### Combining Multiple Futures

- Run Both and Wait for All

```java
class CompletableFutureDemo {
    static void main() {
        CompletableFuture<Void> all =
                CompletableFuture.allOf(f1, f2, f3);
        all.join();
    }
}
```

#### Combine Results

```java
class CompletableFutureDemo {
    static void main() {
        CompletableFuture<String> f1 =
                CompletableFuture.supplyAsync(() -> "Hello");

        CompletableFuture<String> f2 =
                CompletableFuture.supplyAsync(() -> "World");

        f1.thenCombine(f2, (a, b) -> a + " " + b)
                .thenAccept(System.out::println);

    }
}
```

- This is impossible with plain Future.

#### Exception Handling (Critical)

```java
class CompletableFutureDemo {
    static void main() {
        future.get(); // throws checked Exception

        CompletableFuture.supplyAsync(() -> {
                    if (true) throw new RuntimeException("Error");
                    return "Hello";
                })
                .exceptionally(ex -> "Fallback")
                .thenAccept(System.out::println);

    }
}
```

#### Blocking vs Non-Blocking

- If we call 'future.get()'. You are not doing async. You are just delaying blocking.
- Real async means No blocking main thread. Work continues, Callback handles result.

### ThreadPool Behind Completable Future

- By default 'CompletableFuture.supplyAsync()' uses 'ForkJoinPool.commonPool()'. that matters.
- If we are doing blocking I/O inside it, you can kill performance. We have to control the pool.

```java
class CompletableFutureDemo {
    static void main() {
        ExecutorService executor = Executors.newFixedThreadPool(5);

        CompletableFuture.supplyAsync(() -> {
            return "Task";
        }, executor);

    }
}
```

#### When to use What

| Situation                   | Use                                    |
|-----------------------------|----------------------------------------|
| Need simple background task | Future                                 |
| Need async pipeline         | CompletableFuture                      |
| Need chaining               | CompletableFuture                      |
| Need combining              | CompletableFuture                      |
| High-scale service          | CompletableFuture with custom executor |
| Complex reactive system     | Reactive frameworks                    |

| Category  | Method          | What It Does                                                | Returns                 | When to Use                                            |
|-----------|-----------------|-------------------------------------------------------------|-------------------------|--------------------------------------------------------|
| Create    | supplyAsync()   | Executes a task asynchronously that returns a value         | CompletableFuture<T>    | When you need a result from an async task              |
|           | runAsync()      | Executes a task asynchronously that does NOT return a value | CompletableFuture<Void> | When you just want to run something async              |
| Transform | thenApply()     | Transforms result of previous stage (like map)              | CompletableFuture<U>    | When you need to modify/process the result             |
|           | thenAccept()    | Consumes result without returning anything                  | CompletableFuture<Void> | When you want to do something with result (print/save) |
|           | thenRun()       | Runs after previous stage, ignores result                   | CompletableFuture<Void> | When you just want to know previous stage completed    |
| Combine   | thenCombine()   | Combines results of TWO independent futures                 | CompletableFuture<V>    | When you need both results to produce something        |
|           | thenCompose()   | Chains futures (flatMap) - one depends on the other         | CompletableFuture<U>    | When second future depends on first's result           |
| Wait      | join()          | Waits forever, throws unchecked exception                   | T                       | When you don't want to handle InterruptedException     |
|           | get()           | Waits forever, throws checked exceptions                    | T                       | When you want to handle InterruptedException           |
| Error     | exceptionally() | Recovery on exception                                       | CompletableFuture<T>    | When you want to provide fallback value                |
|           | handle()        | Always executes (success or failure)                        | CompletableFuture<U>    | When you need to handle both cases                     |
|           | whenComplete()  | Similar to finally block                                    | CompletableFuture<T>    | When you need to do cleanup/logging                    |

### CREATE Methods

#### supplyAsync() - For Tasks That Return Values

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class SupplyAsyncExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Returns a value (String)
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000); // Simulate API call
                System.out.println("Thread: " + Thread.currentThread().getName());
                return "Hello from Async!";
            } catch (InterruptedException e) {
                return "Error!";
            }
        });

        // Do other work here...
        System.out.println("Main thread is free to do other work!");

        // Get the result when needed
        String result = future.get();
        System.out.println("Result: " + result);
    }
}
```

- output

```text
Main thread is free to do other work!
Thread: ForkJoinPool.commonPool-worker-1
Result: Hello from Async!
```

#### runAsync() - For Tasks That Don't Return Values

```java
public class RunAsyncExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Doesn't return anything (Void)
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(1000);
                System.out.println("Task completed asynchronously!");
                System.out.println("Running on: " + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println("Main thread continues...");

        // Wait for completion (optional)
        future.get(); // Returns null
        System.out.println("All done!");
    }
}
```

output

```text
Main thread continues...
Task completed asynchronously!
Running on: ForkJoinPool.commonPool-worker-1
All done!
```

### TRANSFORM Methods

#### thenApply() - Transform the Result (Like Map)

```java
public class ThenApplyExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Fetching user data...");
                    return "John,30,New York"; // Raw data
                })
                .thenApply(rawData -> {
                    System.out.println("Parsing user data...");
                    String[] parts = rawData.split(",");
                    return parts[0]; // Extract name
                })
                .thenApply(name -> {
                    System.out.println("Formatting name...");
                    return "Mr. " + name; // Format name
                })
                .thenApply(formattedName -> {
                    System.out.println("Getting name length...");
                    return formattedName.length(); // Get length
                });

        System.out.println("Final result (name length): " + future.get());
    }
}
```

output

```text
Fetching user data...
Parsing user data...
Formatting name...
Getting name length...
Final result (name length): 8
```

#### thenAccept() - Consume Result Without Returning

```java
public class ThenAcceptExample {
    public static void main(String[] args) {
        CompletableFuture<Void> future = CompletableFuture
                .supplyAsync(() -> {
                    return "order-12345";
                })
                .thenAccept(orderId -> {
                    // Save to database
                    System.out.println("Saving order " + orderId + " to database...");
                })
                .thenAccept(v -> {
                    // Send email notification
                    System.out.println("Sending confirmation email...");
                });

        future.join(); // Wait for completion
        System.out.println("Order processing complete!");
    }
}
```

output

```text
Saving order order-12345 to database...
Sending confirmation email...
Order processing complete!
```

#### thenRun() - Run After Completion (Ignore Result)

```java
public class ThenRunExample {
    public static void main(String[] args) {
        CompletableFuture<Void> future = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Processing payment...");
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                    return "PAID";
                })
                .thenRun(() -> {
                    System.out.println("Sending SMS notification...");
                })
                .thenRun(() -> {
                    System.out.println("Cleaning up resources...");
                });

        future.join();
    }
}
```

output

```text
Processing payment...
Sending SMS notification...
Cleaning up resources...
```

### Combine Methods

#### thenCombine() - Combine Two Independent Futures

```java
public class ThenCombineExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> future1 = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Fetching price from Amazon...");
                    try {
                        Thread.sleep(2000);
                    } catch (Exception e) {
                    }
                    return 100; // Price from Amazon
                });

        CompletableFuture<Integer> future2 = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Fetching price from eBay...");
                    try {
                        Thread.sleep(1500);
                    } catch (Exception e) {
                    }
                    return 90; // Price from eBay
                });

        CompletableFuture<Integer> combined = future1
                .thenCombine(future2, (amazonPrice, ebayPrice) -> {
                    System.out.println("Amazon: $" + amazonPrice + ", eBay: $" + ebayPrice);
                    return Math.min(amazonPrice, ebayPrice); // Get best price
                });

        System.out.println("Best price: $" + combined.get());
    }
}
```

output

```text
Fetching price from Amazon...
Fetching price from eBay...
Amazon: $100, eBay: $90
Best price: $90
```

#### thenCompose() - Chain Dependent Futures (Like flatMap)

```java
public class ThenComposeExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> future = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Getting user ID...");
                    return "user-123";
                })
                .thenCompose(userId -> {
                    // This future DEPENDS on userId
                    return CompletableFuture.supplyAsync(() -> {
                        System.out.println("Fetching orders for " + userId + "...");
                        try {
                            Thread.sleep(1000);
                        } catch (Exception e) {
                        }
                        return "Order1, Order2, Order3";
                    });
                })
                .thenCompose(orders -> {
                    // This future DEPENDS on orders
                    return CompletableFuture.supplyAsync(() -> {
                        System.out.println("Processing orders: " + orders);
                        return "Order processing complete!";
                    });
                });

        System.out.println("Result: " + future.get());
    }
}
```

output

```text
Getting user ID...
Fetching orders for user-123...
Processing orders: Order1, Order2, Order3
Result: Order processing complete!
```

### WAIT Methods

#### join() vs get() Comparison

```java
public class WaitMethodsExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (Exception e) {
            }
            return "Result";
            // Uncomment to see exception handling:
            // throw new RuntimeException("Something went wrong!");
        });

        // Using join() - Throws unchecked exception
        try {
            String result1 = future.join(); // No try-catch needed for join
            System.out.println("join() result: " + result1);
        } catch (Exception e) {
            System.out.println("join() exception: " + e.getClass());
        }

        // Using get() - Requires try-catch for checked exceptions
        try {
            String result2 = future.get(); // Throws InterruptedException, ExecutionException
            System.out.println("get() result: " + result2);
        } catch (Exception e) {
            System.out.println("get() exception: " + e.getClass());
        }
    }
}
```

output

```text
join() exception: class java.util.concurrent.CompletionException
get() exception: class java.util.concurrent.ExecutionException
```

### ERROR Handling Methods

#### exceptionally() - Provide Fallback on Error

```java
public class ExceptionallyExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture
                .supplyAsync(() -> {
                    System.out.println("Fetching data from API...");
                    if (Math.random() > 0.5) {
                        throw new RuntimeException("API is down!");
                    }
                    return "API Response Data";
                })
                .exceptionally(ex -> {
                    System.out.println("Error: " + ex.getMessage());
                    System.out.println("Using cached data instead...");
                    return "Cached Data"; // Fallback value
                });

        System.out.println("Result: " + future.join());
    }
}
```

output

```text
Fetching data from API...
Error: java.lang.RuntimeException: API is down!
Using cached data instead...
Result: Cached Data
```

#### handle() - Handle Both Success and Failure

```java
public class HandleExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture
                .supplyAsync(() -> {
                    double random = Math.random();
                    System.out.println("Random value: " + random);
                    if (random > 0.7) {
                        throw new RuntimeException("Processing failed!");
                    }
                    return "Processed: " + random;
                })
                .handle((result, exception) -> {
                    if (exception != null) {
                        System.out.println("Error occurred: " + exception.getMessage());
                        return "Default Result due to error";
                    } else {
                        System.out.println("Success! Result: " + result);
                        return result + " (handled)";
                    }
                });

        System.out.println("Final: " + future.join());
    }
}
```

output - success

```text
Random value: 0.45
Success! Result: Processed: 0.45
Final: Processed: 0.45 (handled)
```

output - Erroe

```text
Random value: 0.85
Error occurred: java.lang.RuntimeException: Processing failed!
Final: Default Result due to error
```

#### whenComplete() - Like Finally Block

```java
public class WhenCompleteExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture
                .supplyAsync(() -> {
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                    return "Data loaded";
                    // throw new RuntimeException("Database error!");
                })
                .whenComplete((result, exception) -> {
                    // Always executes (like finally)
                    if (exception != null) {
                        System.out.println("Failed: Closing database connection anyway");
                    } else {
                        System.out.println("Success: Closing database connection");
                    }
                });

        System.out.println("Result: " + future.join());
    }
}
```

output

```text
Success: Closing database connection
Result: Data loaded 
```

## Real Word E-Commerce Example

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class ECommerceExample {
    public static void main(String[] args) {
        System.out.println("=== Starting Order Processing ===");

        CompletableFuture.supplyAsync(() -> {
                    // Step 1: Validate order
                    System.out.println("1. Validating order...");
                    sleep(1000);
                    return "ORDER-123";
                })
                .thenApply(orderId -> {
                    // Step 2: Process payment
                    System.out.println("2. Processing payment for " + orderId + "...");
                    sleep(1500);
                    return "PAID-" + orderId;
                })
                .thenCompose(paymentId -> {
                    // Step 3: Check inventory (depends on payment)
                    System.out.println("3. Checking inventory for " + paymentId + "...");
                    return CompletableFuture.supplyAsync(() -> {
                        sleep(1000);
                        return "IN-STOCK";
                    });
                })
                .thenCombine(
                        // Step 4: Prepare shipping label (independent)
                        CompletableFuture.supplyAsync(() -> {
                            System.out.println("4. Creating shipping label...");
                            sleep(2000);
                            return "SHIPPING-LABEL-789";
                        }),
                        (inventory, shippingLabel) -> {
                            System.out.println("5. Combining inventory and shipping...");
                            return "Package ready with " + shippingLabel;
                        }
                )
                .thenAccept(packageInfo -> {
                    // Step 5: Send to warehouse
                    System.out.println("6. " + packageInfo);
                    System.out.println("7. Sending to warehouse...");
                })
                .handle((result, exception) -> {
                    // Step 6: Handle any errors
                    if (exception != null) {
                        System.out.println("‚ùå Error in order processing: " + exception.getMessage());
                        return "Order failed - refund initiated";
                    } else {
                        System.out.println("‚úÖ Order completed successfully!");
                        return "Order success";
                    }
                })
                .whenComplete((finalResult, exception) -> {
                    // Cleanup
                    System.out.println("üßπ Cleaning up resources...");
                })
                .join(); // Wait for everything

        System.out.println("=== Order Processing Complete ===");
    }

    private static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (Exception e) {
        }
    }
}
```

output:

```text
=== Starting Order Processing ===
1. Validating order...
2. Processing payment for ORDER-123...
4. Creating shipping label...
3. Checking inventory for PAID-ORDER-123...
5. Combining inventory and shipping...
6. Package ready with SHIPPING-LABEL-789
7. Sending to warehouse...
‚úÖ Order completed successfully!
üßπ Cleaning up resources...
=== Order Processing Complete ===
```

Here's the properly aligned table:

| Method            | Input      | Output                    | Purpose                         |
|-------------------|------------|---------------------------|---------------------------------|
| `supplyAsync()`   | Supplier   | `CompletableFuture<T>`    | Start async task with result    |
| `runAsync()`      | Runnable   | `CompletableFuture<Void>` | Start async task without result |
| `thenApply()`     | Function   | `CompletableFuture<U>`    | Transform result                |
| `thenAccept()`    | Consumer   | `CompletableFuture<Void>` | Consume result                  |
| `thenRun()`       | Runnable   | `CompletableFuture<Void>` | Run after completion            |
| `thenCombine()`   | BiFunction | `CompletableFuture<V>`    | Combine two futures             |
| `thenCompose()`   | Function   | `CompletableFuture<U>`    | Chain dependent futures         |
| `exceptionally()` | Function   | `CompletableFuture<T>`    | Recover from error              |
| `handle()`        | BiFunction | `CompletableFuture<U>`    | Handle success/error            |
| `whenComplete()`  | BiConsumer | `CompletableFuture<T>`    | Execute finally block           |