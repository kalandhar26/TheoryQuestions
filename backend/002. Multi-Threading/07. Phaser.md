### Phaser and Exchanger

- Both Phaser and Exchanger are advanced synchronization utilities from java.util.concurrent package:
- Phaser: A flexible, reusable barrier that can synchronize threads across multiple phases with dynamic party
  registration
- Exchanger: A synchronization point where two threads can exchange data safely
- Think of them like:
- Phaser = A conference room where participants can join/leave between sessions, and everyone waits for each session to
  end before starting the next
- Exchanger = A secure handoff point where two spies exchange briefcases simultaneously.

| Method                    | Description                                 | Returns         |
|---------------------------|---------------------------------------------|-----------------|
| Phaser()                  | Creates phaser with no initial parties      | -               |
| Phaser(int parties)       | Creates phaser with fixed number of parties | -               |
| register()                | Adds a new unarrived party                  | Current phase   |
| bulkRegister(int parties) | Adds multiple parties                       | Current phase   |
| arrive()                  | Arrives without waiting                     | Arrival phase   |
| arriveAndDeregister()     | Arrives and reduces party count             | Arrival phase   |
| arriveAndAwaitAdvance()   | Arrives and waits for others                | Next phase      |
| awaitAdvance(int phase)   | Waits for specific phase                    | Next phase      |
| getPhase()                | Gets current phase number                   | Phase number    |
| getRegisteredParties()    | Gets total registered parties               | Party count     |
| getArrivedParties()       | Gets arrived parties                        | Arrived count   |
| getUnarrivedParties()     | Gets unarrived parties                      | Unarrived count |
| isTerminated()            | Checks if phaser is terminated              | boolean         |
| forceTermination()        | Forces termination                          | void            |

#### Core Concepts

```text
Phase 0 (Registration: 3 parties)     Phase 1 (Registration: 4 parties)
     ‚îÇ                                          ‚îÇ
     ‚îÇ  Thread A arrives                        ‚îÇ  Thread A arrives
     ‚îÇ  Thread B arrives                        ‚îÇ  Thread B arrives
     ‚îÇ  Thread C arrives                        ‚îÇ  Thread C arrives
     ‚îÇ          ‚Üì                                ‚îÇ  Thread D arrives (new!)
     ‚îÇ  PHASE 0 COMPLETE                         ‚îÇ          ‚Üì
     ‚îÇ  (Barrier action runs)                    ‚îÇ  PHASE 1 COMPLETE
     ‚îÇ                                          ‚îÇ
     ‚Üì                                          ‚Üì
```

#### Basic Phaser - Dynamic Team Project

```java
import java.util.concurrent.Phaser;
import java.util.concurrent.ThreadLocalRandom;

class TeamMember implements Runnable {
    private final String name;
    private final Phaser phaser;

    public TeamMember(String name, Phaser phaser) {
        this.name = name;
        this.phaser = phaser;
        this.phaser.register(); // Register this member
    }

    @Override
    public void run() {
        try {
            // Phase 1: Planning
            System.out.println(name + " is planning the work...");
            Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 3000));
            System.out.println(name + " completed planning");
            phaser.arriveAndAwaitAdvance(); // Wait for others

            // Phase 2: Development
            System.out.println(name + " is developing...");
            Thread.sleep(ThreadLocalRandom.current().nextInt(2000, 4000));
            System.out.println(name + " completed development");
            phaser.arriveAndAwaitAdvance();

            // Phase 3: Testing
            System.out.println(name + " is testing...");
            Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 2000));
            System.out.println(name + " completed testing");

            // Member leaves the project
            phaser.arriveAndDeregister();
            System.out.println(name + " left the project (remaining: " +
                    phaser.getRegisteredParties() + ")");

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class ProjectPhaser {
    public static void main(String[] args) {
        System.out.println("=== Team Project with Phaser ===\n");

        Phaser phaser = new Phaser(1); // Main thread registers itself
        System.out.println("Project started with " + phaser.getRegisteredParties() +
                " member (main)");

        // Create team members (they register themselves)
        TeamMember[] members = {
                new TeamMember("Alice", phaser),
                new TeamMember("Bob", phaser),
                new TeamMember("Charlie", phaser)
        };

        // Start all members
        for (TeamMember member : members) {
            new Thread(member).start();
        }

        // Main thread also participates
        for (int phase = 0; phase < 3; phase++) {
            System.out.println("\nüìã Phase " + phase + " in progress...");
            System.out.println("   Registered: " + phaser.getRegisteredParties() +
                    ", Arrived: " + phaser.getArrivedParties() +
                    ", Unarrived: " + phaser.getUnarrivedParties());

            // Main thread arrives and waits
            int currentPhase = phaser.arriveAndAwaitAdvance();
            System.out.println("‚úÖ Phase " + (currentPhase - 1) + " completed!\n");
        }

        // Main thread deregisters
        phaser.arriveAndDeregister();
        System.out.println("üèÅ Project completed! Final parties: " +
                phaser.getRegisteredParties());
    }
}
```

output:

```text
=== Team Project with Phaser ===

Project started with 1 member (main)
Alice is planning the work...
Bob is planning the work...
Charlie is planning the work...

üìã Phase 0 in progress...
   Registered: 4, Arrived: 1, Unarrived: 3
Bob completed planning
Charlie completed planning
Alice completed planning
‚úÖ Phase 0 completed!

üìã Phase 1 in progress...
   Registered: 4, Arrived: 1, Unarrived: 3
Alice is developing...
Bob is developing...
Charlie is developing...
Charlie completed development
Bob completed development
Alice completed development
‚úÖ Phase 1 completed!

üìã Phase 2 in progress...
   Registered: 4, Arrived: 1, Unarrived: 3
Alice is testing...
Bob is testing...
Charlie is testing...
Charlie completed testing
Charlie left the project (remaining: 3)
Bob completed testing
Bob left the project (remaining: 2)
Alice completed testing
Alice left the project (remaining: 1)
‚úÖ Phase 2 completed!

üèÅ Project completed! Final parties: 1
```

#### Dynamic Party Registration - Online Gaming Lobby

```java
import java.util.concurrent.Phaser;
import java.util.concurrent.ThreadLocalRandom;
import java.util.ArrayList;
import java.util.List;

class GamePlayer implements Runnable {
    private final String playerName;
    private final Phaser lobbyPhaser;
    private final int skillLevel;

    public GamePlayer(String playerName, Phaser lobbyPhaser) {
        this.playerName = playerName;
        this.lobbyPhaser = lobbyPhaser;
        this.skillLevel = ThreadLocalRandom.current().nextInt(1, 11);
        this.lobbyPhaser.register();
        System.out.println("üë§ " + playerName + " joined lobby (Skill: " + skillLevel + ")");
    }

    @Override
    public void run() {
        try {
            // Wait for game to start
            System.out.println(playerName + " waiting for game to start...");
            lobbyPhaser.arriveAndAwaitAdvance();

            // Phase 1: Game starts
            System.out.println("üéÆ " + playerName + " started playing!");
            Thread.sleep(ThreadLocalRandom.current().nextInt(2000, 5000));
            System.out.println("üèÅ " + playerName + " finished playing!");

            // Leave game
            lobbyPhaser.arriveAndDeregister();

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class GamingLobby {
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=== ONLINE GAME LOBBY ===\n");

        Phaser lobbyPhaser = new Phaser(1); // Lobby manager

        // Simulate players joining over time
        Thread lobbyThread = new Thread(() -> {
            try {
                List<Thread> playerThreads = new ArrayList<>();
                String[] players = {"Alice", "Bob", "Charlie", "Diana", "Eve"};

                for (String player : players) {
                    Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 3000));

                    GamePlayer gp = new GamePlayer(player, lobbyPhaser);
                    Thread t = new Thread(gp);
                    playerThreads.add(t);
                    t.start();

                    System.out.println("   Current players in lobby: " +
                            (lobbyPhaser.getRegisteredParties() - 1));
                }

                // Wait a bit more for late players
                Thread.sleep(2000);

                System.out.println("\nüéØ Minimum players reached! Starting game...");
                System.out.println("Total players: " + (lobbyPhaser.getRegisteredParties() - 1));

                // Start the game
                lobbyPhaser.arriveAndAwaitAdvance(); // Phase 0 complete

                // Wait for game to finish
                Thread.sleep(10000);

                // Check if any players remaining
                if (lobbyPhaser.getRegisteredParties() > 1) {
                    System.out.println("\n‚ö†Ô∏è Forcing game end...");
                    lobbyPhaser.forceTermination();
                }

            } catch (InterruptedException e) {
            }
        });

        lobbyThread.start();
        lobbyThread.join();

        System.out.println("\nüèÜ Game session ended!");
        System.out.println("Terminated: " + lobbyPhaser.isTerminated());
    }
}
```

#### Multi-Stage Data Processing Pipeline

```java
import java.util.concurrent.Phaser;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.*;

class DataItem {
    final int id;
    String data;
    String processed;
    String validated;

    DataItem(int id, String data) {
        this.id = id;
        this.data = data;
    }
}

class ProcessingStage implements Runnable {
    private final String stageName;
    private final Phaser phaser;
    private final Queue<DataItem> inputQueue;
    private final Queue<DataItem> outputQueue;
    private final java.util.function.Function<DataItem, DataItem> processor;

    public ProcessingStage(String stageName, Phaser phaser,
                           Queue<DataItem> inputQueue,
                           Queue<DataItem> outputQueue,
                           java.util.function.Function<DataItem, DataItem> processor) {
        this.stageName = stageName;
        this.phaser = phaser;
        this.inputQueue = inputQueue;
        this.outputQueue = outputQueue;
        this.processor = processor;
        this.phaser.register();
    }

    @Override
    public void run() {
        try {
            while (!phaser.isTerminated()) {
                // Process all available items
                DataItem item;
                int processed = 0;
                while ((item = inputQueue.poll()) != null) {
                    DataItem result = processor.apply(item);
                    outputQueue.offer(result);
                    processed++;
                }

                System.out.println("  " + stageName + " processed " + processed +
                        " items. Queue size: " + outputQueue.size());

                // Wait for next phase
                int phase = phaser.arriveAndAwaitAdvance();

                if (phase >= 3) { // After 3 phases
                    break;
                }
            }
        } finally {
            phaser.arriveAndDeregister();
        }
    }
}

public class DataPipeline {
    public static void main(String[] args) {
        System.out.println("=== Multi-Stage Data Processing Pipeline ===\n");

        // Create queues for each stage
        Queue<DataItem> rawDataQueue = new ConcurrentLinkedQueue<>();
        Queue<DataItem> processedQueue = new ConcurrentLinkedQueue<>();
        Queue<DataItem> validatedQueue = new ConcurrentLinkedQueue<>();
        Queue<DataItem> finalQueue = new ConcurrentLinkedQueue<>();

        // Generate initial data
        for (int i = 1; i <= 10; i++) {
            rawDataQueue.offer(new DataItem(i, "raw-data-" + i));
        }

        Phaser phaser = new Phaser(1); // Main thread

        // Create processing stages
        ProcessingStage stage1 = new ProcessingStage(
                "Stage1-Processor", phaser, rawDataQueue, processedQueue,
                item -> {
                    item.processed = item.data.toUpperCase() + "-PROCESSED";
                    return item;
                }
        );

        ProcessingStage stage2 = new ProcessingStage(
                "Stage2-Enricher", phaser, processedQueue, validatedQueue,
                item -> {
                    item.processed = item.processed + "-ENRICHED";
                    return item;
                }
        );

        ProcessingStage stage3 = new ProcessingStage(
                "Stage3-Validator", phaser, validatedQueue, finalQueue,
                item -> {
                    item.validated = item.processed + "-VALIDATED";
                    return item;
                }
        );

        // Start all stages
        new Thread(stage1).start();
        new Thread(stage2).start();
        new Thread(stage3).start();

        // Monitor progress
        for (int phase = 0; phase < 4; phase++) {
            System.out.println("\nüìä Phase " + phase + " starting");
            System.out.println("   Registered parties: " + phaser.getRegisteredParties());

            int currentPhase = phaser.arriveAndAwaitAdvance();

            System.out.println("‚úÖ Phase " + phase + " completed!");
            System.out.println("   Final queue size: " + finalQueue.size());
        }

        // Display results
        System.out.println("\nüì¶ Final Results:");
        finalQueue.forEach(item ->
                System.out.println("   Item " + item.id + ": " + item.validated));

        phaser.arriveAndDeregister();
    }
}
```

#### Tree Phaser - Parent-Child Relationships

```java
import java.util.concurrent.Phaser;

class Worker extends Thread {
    private final Phaser phaser;
    private final String name;

    public Worker(String name, Phaser phaser) {
        this.name = name;
        this.phaser = phaser;
        phaser.register();
    }

    @Override
    public void run() {
        try {
            System.out.println(name + " starting phase " + phaser.getPhase());
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(name + " completed phase " + phaser.getPhase());
            phaser.arriveAndAwaitAdvance();

            System.out.println(name + " starting phase " + phaser.getPhase());
            Thread.sleep((long) (Math.random() * 1000));
            System.out.println(name + " completed phase " + phaser.getPhase());
            phaser.arriveAndAwaitAdvance();

        } catch (InterruptedException e) {
        }
    }
}

public class TreePhaserExample {
    public static void main(String[] args) {
        System.out.println("=== Tree Phaser - Hierarchical Coordination ===\n");

        // Create root phaser
        Phaser rootPhaser = new Phaser(1);

        // Create child phasers (they inherit from root)
        Phaser team1Phaser = new Phaser(rootPhaser, 1);
        Phaser team2Phaser = new Phaser(rootPhaser, 1);

        System.out.println("Root phaser registered: " + rootPhaser.getRegisteredParties());
        System.out.println("Team1 phaser registered: " + team1Phaser.getRegisteredParties());
        System.out.println("Team2 phaser registered: " + team2Phaser.getRegisteredParties());

        // Team 1 workers
        Worker team1Worker1 = new Worker("Team1-Worker1", team1Phaser);
        Worker team1Worker2 = new Worker("Team1-Worker2", team1Phaser);

        // Team 2 workers
        Worker team2Worker1 = new Worker("Team2-Worker1", team2Phaser);
        Worker team2Worker2 = new Worker("Team2-Worker2", team2Phaser);

        // Start all workers
        team1Worker1.start();
        team1Worker2.start();
        team2Worker1.start();
        team2Worker2.start();

        // Wait for first phase
        System.out.println("\nüå≥ Root waiting for phase 1...");
        int phase = rootPhaser.arriveAndAwaitAdvance();
        System.out.println("üéØ Phase " + phase + " completed for all teams!\n");

        // Wait for second phase
        System.out.println("üå≥ Root waiting for phase 2...");
        phase = rootPhaser.arriveAndAwaitAdvance();
        System.out.println("üéØ Phase " + phase + " completed for all teams!\n");

        rootPhaser.arriveAndDeregister();
    }
}
```

==============================

## Exchanger

### What is Exchanger?

- Exchanger is a synchronization point where two threads can exchange objects. Think of it as a meeting point where two
  people swap items simultaneously.

```text
Thread A                          Thread B
   ‚îÇ                                  ‚îÇ
   ‚îÇ has "Data-A"                     ‚îÇ has "Data-B"
   ‚îÇ                                  ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ Exchanger ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                ‚îÇ
                ‚îÇ Swap happens atomically
                ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ                          ‚îÇ
   ‚ñº                          ‚ñº
Thread A gets "Data-B"    Thread B gets "Data-A"
```

| Method                                           | Description                               | Returns |
|--------------------------------------------------|-------------------------------------------|---------|
| exchange(T x)                                   | Exchanges data, waits for another thread  | T       |
| exchange(T x, long timeout, TimeUnit unit)      | Exchanges data with timeout               | T       |


#### Basic Producer-Consumer Exchange

```java
import java.util.concurrent.Exchanger;
import java.util.concurrent.ThreadLocalRandom;

class DataProducer implements Runnable {
    private final Exchanger<String> exchanger;
    private final String name;
    
    public DataProducer(String name, Exchanger<String> exchanger) {
        this.name = name;
        this.exchanger = exchanger;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 3; i++) {
                // Produce data
                String data = "Data-" + i + "-from-" + name;
                Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 3000));
                
                System.out.println(name + " produced: " + data);
                
                // Exchange with consumer
                String received = exchanger.exchange(data);
                System.out.println("  üîÑ " + name + " received: " + received);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class DataConsumer implements Runnable {
    private final Exchanger<String> exchanger;
    private final String name;
    
    public DataConsumer(String name, Exchanger<String> exchanger) {
        this.name = name;
        this.exchanger = exchanger;
    }
    
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 3; i++) {
                // Consumer has its own data to exchange
                String data = "Processed-" + i + "-by-" + name;
                Thread.sleep(ThreadLocalRandom.current().nextInt(500, 2000));
                
                System.out.println("   " + name + " ready with: " + data);
                
                // Exchange with producer
                String received = exchanger.exchange(data);
                System.out.println(name + " consumed: " + received);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class BasicExchanger {
    public static void main(String[] args) {
        System.out.println("=== Basic Exchanger Example ===\n");
        
        Exchanger<String> exchanger = new Exchanger<>();
        
        DataProducer producer = new DataProducer("Producer", exchanger);
        DataConsumer consumer = new DataConsumer("Consumer", exchanger);
        
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```
output

```text
=== Basic Exchanger Example ===

Consumer ready with: Processed-1-by-Consumer
Producer produced: Data-1-from-Producer
  üîÑ Producer received: Processed-1-by-Consumer
Consumer consumed: Data-1-from-Producer

Consumer ready with: Processed-2-by-Consumer
Producer produced: Data-2-from-Producer
  üîÑ Producer received: Processed-2-by-Consumer
Consumer consumed: Data-2-from-Producer
...
```

#### Buffer Exchange - Efficient Data Processing

```java
import java.util.concurrent.Exchanger;
import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;

class BufferExchanger {
    private static final int BUFFER_SIZE = 5;
    
    static class Buffer {
        final List<Integer> data = new ArrayList<>(BUFFER_SIZE);
        final int id;
        
        Buffer(int id) { this.id = id; }
        
        boolean isFull() { return data.size() >= BUFFER_SIZE; }
        boolean isEmpty() { return data.isEmpty(); }
        
        void add(int value) { data.add(value); }
        void clear() { data.clear(); }
        
        @Override
        public String toString() {
            return "Buffer" + id + data;
        }
    }
    
    static class Producer implements Runnable {
        private final Exchanger<Buffer> exchanger;
        private Buffer buffer;
        private int counter = 0;
        
        public Producer(Exchanger<Buffer> exchanger, Buffer buffer) {
            this.exchanger = exchanger;
            this.buffer = buffer;
        }
        
        @Override
        public void run() {
            try {
                while (counter < 20) {
                    // Fill buffer
                    while (!buffer.isFull() && counter < 20) {
                        buffer.add(counter++);
                        Thread.sleep(100); // Simulate production time
                    }
                    
                    System.out.println("Producer filled: " + buffer);
                    
                    // Exchange full buffer for empty one
                    buffer = exchanger.exchange(buffer);
                    
                    System.out.println("Producer received empty: " + buffer);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    static class Consumer implements Runnable {
        private final Exchanger<Buffer> exchanger;
        private Buffer buffer;
        
        public Consumer(Exchanger<Buffer> exchanger, Buffer buffer) {
            this.exchanger = exchanger;
            this.buffer = buffer;
        }
        
        @Override
        public void run() {
            try {
                while (true) {
                    // Exchange empty buffer for full one
                    buffer = exchanger.exchange(buffer);
                    
                    System.out.println("  Consumer received full: " + buffer);
                    
                    // Process data
                    List<Integer> processed = new ArrayList<>();
                    while (!buffer.isEmpty()) {
                        int value = buffer.data.remove(0);
                        processed.add(value * 10);
                        Thread.sleep(150); // Simulate processing time
                    }
                    
                    System.out.println("  Consumer processed: " + processed);
                    System.out.println("  Consumer now has empty: " + buffer);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Buffer Exchange Pipeline ===\n");
        
        Exchanger<Buffer> exchanger = new Exchanger<>();
        
        // Create initial buffers
        Buffer producerBuffer = new Buffer(1); // Will be filled
        Buffer consumerBuffer = new Buffer(2); // Empty to exchange
        
        Producer producer = new Producer(exchanger, producerBuffer);
        Consumer consumer = new Consumer(exchanger, consumerBuffer);
        
        new Thread(producer).start();
        new Thread(consumer).start();
    }
}
```

#### Genetic Algorithm with Exchanger

```java
import java.util.concurrent.Exchanger;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

class GeneticAlgorithm {
    static class Population {
        final List<Chromosome> chromosomes;
        final int generation;
        double fitness;
        
        Population(int generation, List<Chromosome> chromosomes) {
            this.generation = generation;
            this.chromosomes = chromosomes;
            this.fitness = calculateFitness();
        }
        
        private double calculateFitness() {
            return chromosomes.stream()
                .mapToDouble(c -> c.fitness)
                .average()
                .orElse(0.0);
        }
        
        @Override
        public String toString() {
            return "Gen" + generation + "[fit=" + String.format("%.2f", fitness) + 
                   ", size=" + chromosomes.size() + "]";
        }
    }
    
    static class Chromosome {
        final int[] genes;
        final double fitness;
        
        Chromosome(int length) {
            this.genes = new int[length];
            for (int i = 0; i < length; i++) {
                genes[i] = ThreadLocalRandom.current().nextInt(2);
            }
            this.fitness = evaluateFitness();
        }
        
        Chromosome(int[] genes) {
            this.genes = genes.clone();
            this.fitness = evaluateFitness();
        }
        
        private double evaluateFitness() {
            // Simple fitness: count number of 1s
            int sum = 0;
            for (int gene : genes) sum += gene;
            return (double) sum / genes.length;
        }
        
        @Override
        public String toString() {
            return "Fitness: " + String.format("%.2f", fitness);
        }
    }
    
    static class Island {
        private final String name;
        private final Exchanger<Population> exchanger;
        private Population currentPopulation;
        private int generation = 0;
        
        public Island(String name, Exchanger<Population> exchanger, 
                     int populationSize, int chromosomeLength) {
            this.name = name;
            this.exchanger = exchanger;
            
            // Create initial population
            List<Chromosome> initial = new ArrayList<>();
            for (int i = 0; i < populationSize; i++) {
                initial.add(new Chromosome(chromosomeLength));
            }
            this.currentPopulation = new Population(generation, initial);
        }
        
        public void evolve() {
            try {
                for (int i = 0; i < 5; i++) {
                    // Evolve locally
                    System.out.println(name + " evolving " + currentPopulation);
                    Thread.sleep(ThreadLocalRandom.current().nextInt(1000, 3000));
                    
                    // Select best chromosomes
                    List<Chromosome> best = selectBest(5);
                    
                    // Create next generation
                    generation++;
                    List<Chromosome> nextGen = new ArrayList<>(best);
                    
                    // Add some mutations
                    for (int j = 0; j < 5; j++) {
                        nextGen.add(mutate(best.get(j % best.size())));
                    }
                    
                    Population evolved = new Population(generation, nextGen);
                    
                    // Exchange with other island
                    System.out.println("  " + name + " exchanging population...");
                    Population received = exchanger.exchange(evolved);
                    
                    // Merge populations
                    currentPopulation = merge(evolved, received);
                    
                    System.out.println("  " + name + " merged, new fitness: " + 
                                     String.format("%.2f", currentPopulation.fitness));
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        
        private List<Chromosome> selectBest(int count) {
            currentPopulation.chromosomes.sort(
                (c1, c2) -> Double.compare(c2.fitness, c1.fitness)
            );
            return new ArrayList<>(currentPopulation.chromosomes.subList(0, count));
        }
        
        private Chromosome mutate(Chromosome c) {
            int[] genes = c.genes.clone();
            int pos = ThreadLocalRandom.current().nextInt(genes.length);
            genes[pos] = 1 - genes[pos]; // Flip bit
            return new Chromosome(genes);
        }
        
        private Population merge(Population p1, Population p2) {
            List<Chromosome> merged = new ArrayList<>();
            merged.addAll(p1.chromosomes);
            merged.addAll(p2.chromosomes);
            merged.sort((c1, c2) -> Double.compare(c2.fitness, c1.fitness));
            return new Population(
                Math.max(p1.generation, p2.generation),
                merged.subList(0, 10) // Keep top 10
            );
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Genetic Algorithm with Island Model ===\n");
        
        Exchanger<Population> exchanger = new Exchanger<>();
        
        Island island1 = new Island("Island-1", exchanger, 10, 8);
        Island island2 = new Island("Island-2", exchanger, 10, 8);
        
        Thread t1 = new Thread(island1::evolve);
        Thread t2 = new Thread(island2::evolve);
        
        t1.start();
        t2.start();
    }
}
```

#### Exchanger with Timeout and Error Handling

```java
import java.util.concurrent.Exchanger;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

class SecureHandshake {
    private final Exchanger<String> exchanger = new Exchanger<>();
    private final String secretKey = "SECRET-123";
    
    class Client implements Runnable {
        @Override
        public void run() {
            try {
                System.out.println("üîê Client: Sending handshake...");
                String response = exchanger.exchange("HELLO-SERVER", 2, TimeUnit.SECONDS);
                
                if (response.startsWith("AUTH-")) {
                    System.out.println("‚úÖ Client: Server authenticated with: " + response);
                    
                    // Second exchange for key
                    String keyResponse = exchanger.exchange(secretKey, 2, TimeUnit.SECONDS);
                    System.out.println("üîë Client: Received encrypted key: " + keyResponse);
                }
                
            } catch (TimeoutException e) {
                System.out.println("‚è∞ Client: Handshake timeout!");
            } catch (InterruptedException e) {
                System.out.println("‚ö†Ô∏è Client: Interrupted!");
            }
        }
    }
    
    class Server implements Runnable {
        @Override
        public void run() {
            try {
                // Simulate slow server
                Thread.sleep(1500);
                
                String message = exchanger.exchange("AUTH-456", 3, TimeUnit.SECONDS);
                System.out.println("üñ•Ô∏è Server: Received: " + message);
                
                if (message.equals("HELLO-SERVER")) {
                    String key = exchanger.exchange("ENCRYPTED-KEY", 1, TimeUnit.SECONDS);
                    System.out.println("üñ•Ô∏è Server: Verifying key: " + key);
                    
                    if (secretKey.equals(key)) {
                        System.out.println("üîì Server: Secure connection established!");
                    }
                }
                
            } catch (TimeoutException e) {
                System.out.println("‚è∞ Server: Handshake timeout!");
            } catch (Exception e) {
                System.out.println("‚ö†Ô∏è Server error: " + e.getMessage());
            }
        }
    }
    
    public void runHandshake() {
        new Thread(new Client()).start();
        new Thread(new Server()).start();
    }
    
    public static void main(String[] args) {
        new SecureHandshake().runHandshake();
    }
}
```

=============

#### Real-World Example: Multi-Stage Build Pipeline

```java
import java.util.concurrent.*;
import java.util.*;

class BuildStage {
    final String name;
    final int duration;
    
    BuildStage(String name, int duration) {
        this.name = name;
        this.duration = duration;
    }
}

class BuildWorker implements Runnable {
    private final String workerName;
    private final Phaser phaser;
    private final List<BuildStage> stages;
    private final Map<String, Object> artifacts = new ConcurrentHashMap<>();
    
    public BuildWorker(String workerName, Phaser phaser, List<BuildStage> stages) {
        this.workerName = workerName;
        this.phaser = phaser;
        this.stages = stages;
        this.phaser.register();
    }
    
    @Override
    public void run() {
        try {
            for (int stageIdx = 0; stageIdx < stages.size(); stageIdx++) {
                BuildStage stage = stages.get(stageIdx);
                
                System.out.println("üî® " + workerName + " starting stage: " + stage.name);
                Thread.sleep(stage.duration);
                
                // Produce artifact
                String artifact = workerName + "-" + stage.name + "-output";
                artifacts.put(stage.name, artifact);
                
                System.out.println("‚úÖ " + workerName + " completed stage: " + stage.name);
                
                // Wait for all workers at this stage
                int phase = phaser.arriveAndAwaitAdvance();
                
                if (stageIdx < stages.size() - 1) {
                    // Exchange artifacts between workers (simulated)
                    System.out.println("  üì¶ " + workerName + " sharing artifacts for next stage");
                }
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            phaser.arriveAndDeregister();
        }
    }
}

class BuildOrchestrator {
    private final Phaser phaser = new Phaser(1); // Orchestrator
    private final List<BuildStage> stages = Arrays.asList(
        new BuildStage("Compile", 2000),
        new BuildStage("Test", 1500),
        new BuildStage("Package", 1000),
        new BuildStage("Deploy", 500)
    );
    
    public void startBuild(int workerCount) {
        System.out.println("üèóÔ∏è Starting build with " + workerCount + " workers\n");
        
        // Create and start workers
        for (int i = 1; i <= workerCount; i++) {
            BuildWorker worker = new BuildWorker("Worker-" + i, phaser, stages);
            new Thread(worker).start();
        }
        
        // Monitor build progress
        ScheduledExecutorService monitor = Executors.newSingleThreadScheduledExecutor();
        monitor.scheduleAtFixedRate(() -> {
            System.out.println("\nüìä Build Status: Phase " + phaser.getPhase() + 
                             ", Workers: " + (phaser.getRegisteredParties() - 1) + 
                             ", Arrived: " + phaser.getArrivedParties());
        }, 1, 1, TimeUnit.SECONDS);
        
        try {
            // Wait for all stages to complete
            for (int stageIdx = 0; stageIdx < stages.size(); stageIdx++) {
                System.out.println("\nüéØ Starting " + stages.get(stageIdx).name + " phase");
                int phase = phaser.arriveAndAwaitAdvance();
                System.out.println("‚ú® Completed " + stages.get(phase - 1).name + " phase\n");
            }
            
        } finally {
            monitor.shutdown();
            phaser.arriveAndDeregister();
        }
        
        System.out.println("üöÄ Build pipeline complete!");
    }
}

public class BuildPipeline {
    public static void main(String[] args) {
        BuildOrchestrator orchestrator = new BuildOrchestrator();
        orchestrator.startBuild(3);
    }
}
```

#### Phaser Common pitfalls

```java
public class PhaserPitfalls {
    
    // ‚ùå WRONG: Not handling phase advancement correctly
    public void wrongPhaser() {
        Phaser phaser = new Phaser(3);
        
        // In threads:
        int phase = phaser.getPhase();
        phaser.arriveAndAwaitAdvance();
        // Thread assumes it's now in phase+1, but might be terminated!
        if (phaser.isTerminated()) {
            // Handle termination
        }
    }
    
    // ‚úÖ CORRECT: Check termination
    public void correctPhaser() {
        Phaser phaser = new Phaser(3);
        
        while (!phaser.isTerminated()) {
            int phase = phaser.arriveAndAwaitAdvance();
            if (phase < 0) {
                System.out.println("Phaser terminated");
                break;
            }
            // Safe to proceed
        }
    }
    
    // ‚ùå WRONG: Forgetting to deregister
    public void memoryLeak() {
        Phaser phaser = new Phaser();
        
        for (int i = 0; i < 1000; i++) {
            new Thread(() -> {
                phaser.register(); // Never deregistered!
                // work
                phaser.arrive(); // But never deregister
            }).start();
        }
        // Parties keep growing! Memory leak!
    }
    
    // ‚úÖ CORRECT: Always deregister
    public void noLeak() {
        Phaser phaser = new Phaser();
        
        new Thread(() -> {
            phaser.register();
            try {
                // work
                phaser.arriveAndAwaitAdvance();
            } finally {
                phaser.arriveAndDeregister(); // Always deregister
            }
        }).start();
    }
}
```

#### Exchanger Pitfalls

```java
public class ExchangerPitfalls {
    
    // ‚ùå WRONG: Only one thread exchanges
    public void deadlock() {
        Exchanger<String> exchanger = new Exchanger<>();
        
        new Thread(() -> {
            try {
                String result = exchanger.exchange("Hello");
                System.out.println("Got: " + result);
            } catch (InterruptedException e) {}
        }).start();
        
        // Only one thread - hangs forever!
    }
    
    // ‚úÖ CORRECT: Always have pair of threads
    public void correctExchange() {
        Exchanger<String> exchanger = new Exchanger<>();
        
        new Thread(() -> {
            try {
                String result = exchanger.exchange("Hello");
                System.out.println("T1 got: " + result);
            } catch (InterruptedException e) {}
        }).start();
        
        new Thread(() -> {
            try {
                String result = exchanger.exchange("World");
                System.out.println("T2 got: " + result);
            } catch (InterruptedException e) {}
        }).start();
    }
    
    // ‚úÖ Use timeout to prevent deadlock
    public void safeExchange() {
        Exchanger<String> exchanger = new Exchanger<>();
        
        new Thread(() -> {
            try {
                String result = exchanger.exchange("Hello", 2, TimeUnit.SECONDS);
                System.out.println("Got: " + result);
            } catch (TimeoutException e) {
                System.out.println("Timeout - no partner available");
            } catch (InterruptedException e) {}
        }).start();
    }
}
```

#### Cheat Sheet

```java 
class PhaserCheatSheet {
    static void main() {
        // Create phaser
        Phaser phaser = new Phaser(); // No parties
        Phaser phaser = new Phaser(3); // With 3 parties

// Register/deregister
        phaser.register();
        phaser.bulkRegister(5);
        phaser.arriveAndDeregister();

// Arrive and wait
        int phase = phaser.arrive(); // Don't wait
        int phase = phaser.awaitAdvance(phase); // Wait for specific phase
        int phase = phaser.arriveAndAwaitAdvance(); // Most common

// Check status
        int parties = phaser.getRegisteredParties();
        int arrived = phaser.getArrivedParties();
        int unarrived = phaser.getUnarrivedParties();
        int currentPhase = phaser.getPhase();
        boolean terminated = phaser.isTerminated();

// Force termination
        phaser.forceTermination();
    }
}
```

```java 
class ExchangerCheatSheet {
    static void main() {
        // Create exchanger
        Exchanger<String> exchanger = new Exchanger<>();

// Exchange data (blocks)
        String received = exchanger.exchange(myData);

// Exchange with timeout
        String received = exchanger.exchange(myData, 2, TimeUnit.SECONDS);

// Common pattern in producer-consumer
        while (!Thread.currentThread().isInterrupted()) {
            try {
                // Produce
                T data = produce();
                // Exchange
                T result = exchanger.exchange(data);
                // Consume result
                consume(result);
            } catch (InterruptedException e) {
                break;
            } catch (TimeoutException e) {
                // Handle timeout
            }
        }
    }
}
```

