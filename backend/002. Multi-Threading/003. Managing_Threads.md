### Managing Threads

- Creating threads is easy.
- Managing them is where most developers fail.

#### Controlling Execution Order

**Using Join**

class ThreadsDemo{
}

```java
class ThreadsDemo {
    static void main() {
        Thread t = new Thread(() -> {
            System.out.println("Child thread");
        });

        t.start();
        t.join(); // main waits

    }

}
```

- Main thread waits for child to finish.

**Sleeping** and **Setting Priority** and **Interrupting Thread**

```java
class ThreadsDemo {
    static void main() {
        Thread t = new Thread(() -> {
            System.out.println("Child thread");
        });

        t.start();
        t.join();
        Thread.sleep(1000); // Pauses current thread.
        t.setPriority(Thread.MAX_PRIORITY); // But OS decides actual scheduling.
        t.interrupt(); // Used to signal thread to stop.

        // Thread must handle:
        if (Thread.currentThread().isInterrupted()) {
            return;
        }
    }
}
```

### Thread Safety (Critical Section)

- When multiple threads share data: You get race conditions.

```java
class BankAccount {
    private int balance = 1000;

    public void withdraw(int amount) {
        // PROBLEM: Multiple threads can execute this simultaneously
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() + " is withdrawing...");

            // Simulate some processing time
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }

            balance = balance - amount;
            System.out.println(Thread.currentThread().getName() +
                    " completed withdrawal. Remaining: $" + balance);
        } else {
            System.out.println(Thread.currentThread().getName() +
                    " - Insufficient funds!");
        }
    }

    public int getBalance() {
        return balance;
    }
}

// Let's test the problem
public class ThreadProblem {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();

        // Two people trying to withdraw $800 each from $1000 account
        Runnable task = () -> {
            account.withdraw(800);
        };

        Thread wife = new Thread(task, "Wife");
        Thread husband = new Thread(task, "Husband");

        wife.start();
        husband.start();
    }
}
```

- output

```text
Wife is withdrawing...
Husband is withdrawing...
Wife completed withdrawal. Remaining: $200
Husband completed withdrawal. Remaining: $-600  <-- OVERDRAFT! Account corrupted!
```

**Synchronized**

```java
class SafeBankAccount {
    private int balance = 1000;

    // synchronized = Only one thread can enter this method at a time
    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() + " is withdrawing...");

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }

            balance = balance - amount;
            System.out.println(Thread.currentThread().getName() +
                    " completed. Remaining: $" + balance);
        } else {
            System.out.println(Thread.currentThread().getName() +
                    " - Insufficient funds!");
        }
    }
}

// Test it
public class SynchronizedSolution {
    public static void main(String[] args) {
        SafeBankAccount account = new SafeBankAccount();

        Runnable task = () -> account.withdraw(800);

        Thread t1 = new Thread(task, "Thread-1");
        Thread t2 = new Thread(task, "Thread-2");

        t1.start();
        t2.start();
    }
}
```

- output

```text
Thread-1 is withdrawing...
Thread-1 completed. Remaining: $200
Thread-2 - Insufficient funds!  <-- Properly handled!
```

**Lock**

- more flexible than synchronized

```java
import java.util.concurrent.locks.Lock;

class LockBankAccount {
    private int balance = 1000;
    private final Lock lock = new ReentrantLock();

    public void withdraw(int amount) {
        lock.lock();  // Get the lock
        try {
            if (balance >= amount) {
                System.out.println(Thread.currentThread().getName() + " is withdrawing...");

                Thread.sleep(100);

                balance = balance - amount;
                System.out.println(Thread.currentThread().getName() +
                        " completed. Remaining: $" + balance);
            } else {
                System.out.println(Thread.currentThread().getName() +
                        " - Insufficient funds!");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();  // ALWAYS release lock in finally block
        }
    }

    // Lock advantage: Can try to acquire lock with timeout
    public boolean tryWithdraw(int amount, long timeoutSeconds) {
        try {
            if (lock.tryLock(timeoutSeconds, java.util.concurrent.TimeUnit.SECONDS)) {
                try {
                    // Perform withdrawal...
                    return true;
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println("Couldn't acquire lock - doing something else");
                return false;
            }
        } catch (InterruptedException e) {
            return false;
        }
    }
}
```

**Atomic Variables**

- More Efficient and Safe

```java
import java.util.concurrent.atomic.AtomicInteger;

class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        // Atomic: Happens in one CPU operation - no locking needed!
        int newValue = count.incrementAndGet();
        System.out.println(Thread.currentThread().getName() +
                " incremented to: " + newValue);
    }

    public int getCount() {
        return count.get();
    }
}

// Multiple threads incrementing counter
public class AtomicDemo {
    public static void main(String[] args) throws InterruptedException {
        AtomicCounter counter = new AtomicCounter();

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task, "Thread-A");
        Thread t2 = new Thread(task, "Thread-B");

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Final count: " + counter.getCount()); // Always 2000!
    }
}
```

### Real world Example

```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReentrantLock;

class MovieTicketSystem {
    private AtomicInteger availableSeats = new AtomicInteger(100);
    private final ReentrantLock bookingLock = new ReentrantLock();

    // Method 1: Simple booking with AtomicInteger
    public boolean bookTicketAtomic(String customerName) {
        int currentSeats;
        do {
            currentSeats = availableSeats.get();
            if (currentSeats <= 0) {
                System.out.println("Sorry " + customerName + ", no seats available!");
                return false;
            }
            // Atomic compare-and-set
        } while (!availableSeats.compareAndSet(currentSeats, currentSeats - 1));

        System.out.println(customerName + " booked a seat! Remaining: " +
                (currentSeats - 1));
        return true;
    }

    // Method 2: Complex booking with multiple operations using Lock
    public boolean bookPremiumSeat(String customerName, String seatNumber) {
        bookingLock.lock();
        try {
            System.out.println(customerName + " is booking premium seat " + seatNumber);

            // Complex logic here (check seat availability, process payment, etc.)
            Thread.sleep(1000); // Simulate processing

            System.out.println(customerName + " successfully booked premium seat!");
            return true;

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        } finally {
            bookingLock.unlock();
        }
    }
}

// Test the booking system
public class TicketBookingDemo {
    public static void main(String[] args) {
        MovieTicketSystem ticketSystem = new MovieTicketSystem();

        // Simulate 20 people booking tickets
        for (int i = 1; i <= 20; i++) {
            final int customerId = i;
            new Thread(() -> {
                ticketSystem.bookTicketAtomic("Customer-" + customerId);
            }).start();
        }
    }
}
```
